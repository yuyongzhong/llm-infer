<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net; object-src 'none';">
  <title>å¤§æ¨¡å‹æµ‹è¯• Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
  <script src="https://cdn.jsdelivr.net/npm/tinycolor2@1.6.0/dist/tinycolor-min.js"></script>
  <!-- åœ¨å·²æœ‰ä¾èµ–åæ·»åŠ  -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.9/dist/echarts-gl.min.js"></script>
  <script>
  // åœ¨ç¬¬ä¸€ä¸ª script æ ‡ç­¾å¼€å§‹å¤„æ·»åŠ 
  document.addEventListener('DOMContentLoaded', () => {
    // ç¡®ä¿ echarts åŠ è½½å®Œæˆ
    if (!window.echarts) {
      console.error('ECharts æœªèƒ½æ­£ç¡®åŠ è½½');
      return;
    }
    
    // æ£€æŸ¥ 3D ç»„ä»¶
    if (!echarts.getMap) {
      console.error('ECharts 3D ç»„ä»¶æœªåŠ è½½');
    }
    
    console.log('ECharts ç‰ˆæœ¬:', echarts.version);
  });
  </script>
  <style>
    body {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%);
      font-family: "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
      color: #1e293b;
      padding: 2em 0 3em 0;
      min-height: 100vh;
    }
    .container {
      background: #ffffff;
      padding: 2em 2.5em 2.5em 2.5em;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.08), 0 8px 25px rgba(0,0,0,0.06);
      max-width: 1600px;
      margin: 38px auto 0 auto;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.8);
    }
    h1 {
      font-size: 2.5em;
      font-weight: 800;
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 50%, #1d4ed8 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.01em;
      margin-bottom: 0.5em;
      line-height: 1.2;
      text-align: center;
    }
    .device-group {
      margin-bottom: 2.4em;
      border-radius: 16px;
      box-shadow: 0 1.5px 7px rgba(80,110,160,0.04);
      background: #f7faff;
      padding: 1.3em 1.6em 1.5em 1.6em;
      text-align: left;
    }
    .device-title {
      font-size: 1.33em;
      color: #284e87;
      margin-bottom: .65em;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: .4em;
    }
    .summary-cards {
      display: flex;
      gap: 1.2em;
      margin-bottom: 1.1em;
      flex-wrap: wrap;
    }
    .summary-card {
      background: linear-gradient(105deg, #dcefff 0%, #f1f6fc 100%);
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(80,130,200,0.07);
      min-width: 150px;
      padding: 1.1em 1.1em 1.05em 1.1em;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 1.02em;
      font-weight: 600;
      color: #1a3062;
    }
    .summary-card .card-title {
      font-size: 0.98em;
      color: #4271b6;
      margin-bottom: .2em;
      font-weight: 400;
      letter-spacing: .02em;
    }
    .summary-card .card-value {
      font-size: 1.42em;
      font-weight: 800;
      color: #145cce;
      letter-spacing: .01em;
    }
    .chart-wrap {
      position: relative;
      margin: 1.5em 0 2em 0;
      background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08), 0 1px 3px rgba(0,0,0,0.1);
      padding: 1.8em;
      min-height: 500px;
      width: 100%;
      overflow: visible;
      border: 1px solid rgba(226, 232, 240, 0.8);
    }
    .chart-wrap > div:not(.chart-title) {
      width: 100% !important;
      height: 100% !important;
      min-height: 450px;  /* ç¡®ä¿å›¾è¡¨å®¹å™¨æœ‰è¶³å¤Ÿé«˜åº¦ */
    }
    .chart-title {
      font-size: 1.3em;
      font-weight: 700;
      margin-bottom: 1.2em;
      color: #1e40af;
      text-align: left;
      padding-bottom: 0.5em;
      border-bottom: 2px solid #e2e8f0;
    }
    .version-section {
      border-top: 1px solid #e4eaf0;
      margin-top: 1.2em;
      padding-top: 1em;
    }
    .model-block {
      margin-top: 1.1em;
      padding: 1em 1em 0.8em 1em;
      background: #fcfdff;
      border-radius: 8px;
      box-shadow: 0 1.5px 5px rgba(0,0,0,0.04);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1em 0;
    }
    th, td {
      border: 1px solid #dde1ee;
      padding: 0.45em 0.5em;
      text-align: center;
      font-size: 1em;
    }
    th {
      background: linear-gradient(90deg, #e5edfd 60%, #f6f9fe 100%);
      color: #23549c;
      font-size: 1.05em;
      font-weight: 700;
      letter-spacing: .01em;
      border-bottom: 2.5px solid #bdd2f8;
    }
    code {
      background: #f0f3f9;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 1.01em;
    }
    select {
      margin-bottom: 1em;
      padding: 0.35em;
    }
    .footer {
      margin-top: 4em;
      color: #6886ad;
      font-size: 0.99em;
      text-align: center;
      letter-spacing: .02em;
      opacity: 0.88;
      border-top: 1.5px dashed #c8d6ee;
      padding-top: 1.3em;
    }
    .footer span {
      font-weight: 600;
      color: #295cb8;
      margin-left: 0.5em;
      margin-right: 0.5em;
    }
    @media (max-width: 900px) {
      .container { padding: 0.7em 0.2em 1.1em 0.2em; }
      .summary-cards { flex-direction: column; gap: 0.7em; }
    }
    
    /* åœ¨å·²æœ‰æ ·å¼åæ·»åŠ  */
    .chart-wrap {
      position: relative;
    }
    
    .chart-filter {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }
    
    select.token-filter {
      background-color: white;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 4px 24px 4px 8px;
      font-size: 0.9em;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    select.token-filter:hover {
      border-color: #cbd5e0;
    }

    /* æ·»åŠ åˆ°ç°æœ‰æ ·å¼ä¸­ */
    .chart-filters select {
      background-color: white;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 4px 24px 4px 8px;
      font-size: 0.9em;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.2s;
    }

    .chart-filters select:hover {
      border-color: #cbd5e0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .chart-filters label {
      font-size: 0.9em;
      color: #4a5568;
    }

    /* ç­›é€‰å™¨æ ·å¼ */
    .filter-container {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid #cbd5e0;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    /* å›¾è¡¨é…ç½®å™¨æ ·å¼ */
    .chart-config-container {
      background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
      border: 2px solid #fb923c;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(251,146,60,0.15);
    }

    .chart-config-title {
      font-size: 1.1em;
      font-weight: 700;
      color: #ea580c;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chart-config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }

    .chart-type-selector {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    .chart-type-option {
      flex: 1;
      padding: 12px;
      border: 2px solid #fed7aa;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
    }

    .chart-type-option:hover {
      border-color: #fb923c;
      background: #fff7ed;
    }

    .chart-type-option.active {
      border-color: #ea580c;
      background: #fed7aa;
      color: #ea580c;
      font-weight: 600;
    }

    .axis-config {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    .axis-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .axis-group label {
      font-size: 0.9em;
      color: #ea580c;
      font-weight: 600;
    }

    .axis-group select {
      background-color: white;
      border: 2px solid #fed7aa;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.9em;
      color: #374151;
      cursor: pointer;
    }

    .axis-group select:focus {
      outline: none;
      border-color: #fb923c;
    }

    /* ç»´åº¦é…ç½®æ ·å¼ */
    .dimension-config {
      padding: 12px;
      border: 2px solid #fed7aa;
      border-radius: 8px;
      background: white;
      transition: all 0.2s ease;
    }

    .dimension-config.active {
      border-color: #fb923c;
      background: #fff7ed;
    }

    .dimension-config.disabled {
      opacity: 0.6;
      background: #f9fafb;
    }

    .dimension-header {
      margin-bottom: 8px;
      color: #ea580c;
      font-size: 0.9em;
      display: flex;
      align-items: center;
    }

    .dimension-config select:disabled {
      background-color: #f3f4f6;
      color: #9ca3af;
      cursor: not-allowed;
    }

    /* å›¾è¡¨å®¹å™¨æ ·å¼ä¼˜åŒ– */
    .chart-container {
      width: 1000px !important;
      height: 500px !important;
      margin: 0 auto !important;
      padding: 0 !important;
    }

    .chart-wrap {
      width: 100%;
      margin-bottom: 20px;
      padding: 0;
    }

    .chart-wrap .chart-container {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .filter-title {
      font-size: 1.1em;
      font-weight: 700;
      color: #2d3748;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .filter-group {
      position: relative;
    }

    .filter-group label {
      font-size: 0.9em;
      color: #4a5568;
      font-weight: 600;
      margin-bottom: 6px;
      display: block;
    }

    .filter-group {
      position: relative;
    }

    .filter-group select {
      width: 100%;
      background-color: white;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      padding: 8px 32px 8px 12px;
      font-size: 0.9em;
      color: #374151;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 8px center;
      background-repeat: no-repeat;
      background-size: 16px;
      height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .filter-group select[multiple] {
      height: auto;
      min-height: 40px;
      max-height: 200px;
      overflow-y: auto;
      white-space: normal;
    }

    .filter-group select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      height: auto;
      min-height: 120px;
    }

    .filter-group select:hover {
      border-color: #cbd5e0;
    }

    .filter-group select option {
      padding: 6px 12px;
      margin: 1px 0;
      background-color: white;
      color: #374151;
    }

    .filter-group select option:checked {
      background-color: #3b82f6 !important;
      color: white !important;
    }

    .filter-group select option:hover {
      background-color: #f3f4f6;
    }

    /* é€‰ä¸­é¡¹è®¡æ•°æ˜¾ç¤º */
    .filter-group::after {
      content: attr(data-selected-count);
      position: absolute;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
      background: #3b82f6;
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 0.75em;
      font-weight: 600;
      pointer-events: none;
      display: none;
    }

    .filter-group.has-selection::after {
      display: block;
    }

    /* è¡¨æ ¼æ ·å¼ */
    .data-table-container {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin: 16px 0;
      overflow-x: auto;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9em;
    }

    .data-table th {
      background: #f8fafc;
      color: #374151;
      font-weight: 600;
      padding: 8px 12px;
      text-align: left;
      border-bottom: 2px solid #e5e7eb;
      white-space: nowrap;
    }

    .data-table td {
      padding: 6px 12px;
      border-bottom: 1px solid #f3f4f6;
      color: #6b7280;
    }

    .data-table tbody tr:hover {
      background-color: #f9fafb;
    }

    .data-table .number {
      text-align: right;
      font-family: 'Courier New', monospace;
      color: #1f2937;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>å¤§æ¨¡å‹æµ‹è¯• Dashboard</h1>
    <div id="app">ğŸ“¦ æ­£åœ¨åŠ è½½æ•°æ®â€¦</div>
  </div>
  <div class="footer">
    Powered by <span>å¤§æ¨¡å‹æ¨ç†æµ‹è¯•</span> | å¯è§†åŒ–å‡çº§å®šåˆ¶ <span>ChatGPT Plus</span> | <span>2025</span>
  </div>
  <script>
    const COLOR_PALETTE = [
      "#4472c4", "#ed7d31", "#70ad47", "#ffc000", "#5b9bd5",
      "#a5a5a5", "#264478", "#9e480e", "#636363", "#997300",
      "#b855a1", "#2196f3", "#8bc34a", "#ff9800", "#00bcd4",
      "#009688", "#d32f2f", "#ffeb3b", "#795548", "#607d8b"
    ];
    function getBarGradient(ctx, chartArea, color1, color2) {
      const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
      gradient.addColorStop(0, color1);
      gradient.addColorStop(1, color2);
      return gradient;
    }
    function parseVersion(v) {
      return v.split('.').map(n => parseInt(n));
    }
    function compareVersionDesc(a, b) {
      const va = parseVersion(a), vb = parseVersion(b);
      for (let i = 0; i < Math.max(va.length, vb.length); i++) {
        const na = va[i] || 0, nb = vb[i] || 0;
        if (na !== nb) return nb - na;
      }
      return 0;
    }
    function compareVersionAsc(a, b) {
      // å°†ç‰ˆæœ¬å·åˆ†è§£ä¸ºæ•°å­—éƒ¨åˆ†å’Œåç¼€éƒ¨åˆ†
      const [aBase, aSuffix=''] = a.split('_');
      const [bBase, bSuffix=''] = b.split('_');

      // æ¯”è¾ƒåŸºç¡€ç‰ˆæœ¬å·
      const va = parseVersion(aBase);
      const vb = parseVersion(bBase);

      // å…ˆæ¯”è¾ƒæ•°å­—éƒ¨åˆ†
      for (let i = 0; i < Math.max(va.length, vb.length); i++) {
        const na = va[i] || 0;
        const nb = vb[i] || 0;
        if (na !== nb) return na - nb;
      }

      // å¦‚æœæ•°å­—éƒ¨åˆ†ç›¸åŒï¼Œæœ‰ beta åç¼€çš„ç‰ˆæœ¬æ’åœ¨å‰é¢
      if (aBase === bBase) {
        if (aSuffix.includes('beta')) return -1;
        if (bSuffix.includes('beta')) return 1;
      }

      return 0;
    }

    // åˆ›å»ºå›¾è¡¨é…ç½®å™¨
    function createChartConfigContainer(perfRows, device) {
      const container = document.createElement('div');
      container.className = 'chart-config-container';

      container.innerHTML = `
        <div class="chart-config-title">
          ğŸ“Š å›¾è¡¨é…ç½®å™¨ - äºŒç»´å›¾è¡¨é…ç½®
          <div style="font-size: 0.8em; color: #666; margin-top: 4px;">å›ºå®šä¸éœ€è¦çš„ç»´åº¦ï¼Œé€‰æ‹©è¦å¯¹æ¯”çš„ç»´åº¦</div>
        </div>

        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 20px;">
          <!-- ç»´åº¦1 -->
          <div class="dimension-config" id="dim1-config">
            <div class="dimension-header">
              <strong>ğŸ“Œ ç»´åº¦1 (å›ºå®š)</strong>
            </div>
            <div class="axis-group">
              <label>é€‰æ‹©ç»´åº¦</label>
              <select id="dim1-select">
                <option value="">è¯·é€‰æ‹©...</option>
                <option value="model">æ¨¡å‹</option>
                <option value="version">ç‰ˆæœ¬</option>
                <option value="concurrency">å¹¶å‘æ•°</option>
                <option value="token_combination">è¾“å…¥/è¾“å‡º</option>
              </select>
            </div>
            <div class="axis-group" id="dim1-value-group" style="display: none;">
              <label>å›ºå®šä¸º</label>
              <select id="dim1-value">
                <option value="">é€‰æ‹©å€¼...</option>
              </select>
            </div>
          </div>

          <!-- ç»´åº¦2 -->
          <div class="dimension-config" id="dim2-config">
            <div class="dimension-header">
              <strong>ğŸ“Œ ç»´åº¦2 (å›ºå®š)</strong>
            </div>
            <div class="axis-group">
              <label>é€‰æ‹©ç»´åº¦</label>
              <select id="dim2-select" disabled>
                <option value="">è¯·é€‰æ‹©...</option>
                <option value="model">æ¨¡å‹</option>
                <option value="version">ç‰ˆæœ¬</option>
                <option value="concurrency">å¹¶å‘æ•°</option>
                <option value="token_combination">è¾“å…¥/è¾“å‡º</option>
              </select>
            </div>
            <div class="axis-group" id="dim2-value-group" style="display: none;">
              <label>å›ºå®šä¸º</label>
              <select id="dim2-value">
                <option value="">é€‰æ‹©å€¼...</option>
              </select>
            </div>
          </div>

          <!-- ç»´åº¦3 -->
          <div class="dimension-config" id="dim3-config">
            <div class="dimension-header">
              <strong>ğŸ“Œ ç»´åº¦3 (å¯é€‰å›ºå®š)</strong>
              <label style="margin-left: 8px; font-weight: normal;">
                <input type="checkbox" id="dim3-enable"> å¯ç”¨
              </label>
            </div>
            <div class="axis-group">
              <label>é€‰æ‹©ç»´åº¦</label>
              <select id="dim3-select" disabled>
                <option value="">è¯·é€‰æ‹©...</option>
                <option value="model">æ¨¡å‹</option>
                <option value="version">ç‰ˆæœ¬</option>
                <option value="concurrency">å¹¶å‘æ•°</option>
                <option value="token_combination">è¾“å…¥/è¾“å‡º</option>
              </select>
            </div>
            <div class="axis-group" id="dim3-value-group" style="display: none;">
              <label>å›ºå®šä¸º</label>
              <select id="dim3-value">
                <option value="">é€‰æ‹©å€¼...</option>
              </select>
            </div>
          </div>

          <!-- Xè½´é€‰æ‹© -->
          <div class="dimension-config" id="x-axis-config">
            <div class="dimension-header">
              <strong>ğŸ“Š Xè½´</strong>
            </div>
            <div class="axis-group">
              <label>é€‰æ‹©ç»´åº¦</label>
              <select id="x-axis-select" disabled>
                <option value="">è¯·é€‰æ‹©...</option>
                <option value="model">æ¨¡å‹</option>
                <option value="version">ç‰ˆæœ¬</option>
                <option value="concurrency">å¹¶å‘æ•°</option>
                <option value="token_combination">è¾“å…¥/è¾“å‡º</option>
              </select>
            </div>
            <div id="legend-info" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-radius: 4px; font-size: 0.85em; display: none;">
              <strong>å›¾ä¾‹åˆ†ç»„:</strong> <span id="legend-dim"></span>
            </div>
          </div>
        </div>

        <div id="chart-summary" style="padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6; display: none;">
          <strong>ğŸ“‹ å›¾è¡¨é…ç½®æ€»ç»“:</strong>
          <div id="summary-content" style="margin-top: 8px; font-size: 0.9em;"></div>
        </div>
      `;

      // å˜é‡é€‰é¡¹
      const variableOptions = [
        { value: 'model', label: 'æ¨¡å‹' },
        { value: 'version', label: 'ç‰ˆæœ¬' },
        { value: 'concurrency', label: 'å¹¶å‘æ•°' },
        { value: 'token_combination', label: 'è¾“å…¥/è¾“å‡º' }
      ];

      // è·å–å·²é€‰æ‹©çš„ç»´åº¦
      function getSelectedDimensions() {
        const selected = [];
        const dim1 = container.querySelector('#dim1-select').value;
        const dim2 = container.querySelector('#dim2-select').value;
        const dim3 = container.querySelector('#dim3-select').value;
        const dim3Enabled = container.querySelector('#dim3-enable').checked;

        if (dim1) selected.push(dim1);
        if (dim2) selected.push(dim2);
        if (dim3Enabled && dim3) selected.push(dim3);

        return selected;
      }

      // æ›´æ–°å¯é€‰ç»´åº¦
      function updateAvailableOptions() {
        const selectedDims = getSelectedDimensions();
        const selects = [
          container.querySelector('#dim1-select'),
          container.querySelector('#dim2-select'),
          container.querySelector('#dim3-select'),
          container.querySelector('#x-axis-select')
        ];

        selects.forEach(select => {
          if (!select) return;

          Array.from(select.options).forEach(option => {
            if (option.value === '') return;

            // å¦‚æœæ˜¯å½“å‰é€‰æ‹©å™¨çš„å€¼ï¼Œä¿æŒå¯ç”¨
            if (option.value === select.value) {
              option.disabled = false;
              return;
            }

            // å¦‚æœè¢«å…¶ä»–é€‰æ‹©å™¨é€‰ä¸­ï¼Œç¦ç”¨
            option.disabled = selectedDims.includes(option.value);
          });
        });

        // æ›´æ–°Xè½´å¯é€‰é¡¹
        updateXAxisOptions();
      }

      // æ›´æ–°Xè½´é€‰é¡¹
      function updateXAxisOptions() {
        const selectedDims = getSelectedDimensions();
        const xAxisSelect = container.querySelector('#x-axis-select');
        const availableDims = variableOptions.filter(opt => !selectedDims.includes(opt.value));

        // æ¸…ç©ºå¹¶é‡æ–°å¡«å……Xè½´é€‰é¡¹
        xAxisSelect.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>' +
          availableDims.map(dim => `<option value="${dim.value}">${dim.label}</option>`).join('');

        // å¯ç”¨Xè½´é€‰æ‹©å™¨ï¼ˆå¦‚æœæœ‰å¯é€‰é¡¹ï¼‰
        xAxisSelect.disabled = availableDims.length === 0;

        // æ›´æ–°å›¾ä¾‹ä¿¡æ¯
        updateLegendInfo();
      }

      // æ›´æ–°å›¾ä¾‹ä¿¡æ¯
      function updateLegendInfo() {
        const selectedDims = getSelectedDimensions();
        const xAxis = container.querySelector('#x-axis-select').value;
        const legendInfo = container.querySelector('#legend-info');
        const legendDim = container.querySelector('#legend-dim');

        if (xAxis) {
          const allUsedDims = [...selectedDims, xAxis];
          const remainingDims = variableOptions.filter(opt => !allUsedDims.includes(opt.value));

          if (remainingDims.length === 1) {
            legendDim.textContent = remainingDims[0].label;
            legendInfo.style.display = 'block';
          } else if (remainingDims.length > 1) {
            legendDim.textContent = remainingDims.map(d => d.label).join('ã€');
            legendInfo.style.display = 'block';
          } else {
            legendInfo.style.display = 'none';
          }
        } else {
          legendInfo.style.display = 'none';
        }

        updateSummary();
      }

      // æ›´æ–°é…ç½®æ€»ç»“
      function updateSummary() {
        const dim1 = container.querySelector('#dim1-select').value;
        const dim1Value = container.querySelector('#dim1-value').value;
        const dim2 = container.querySelector('#dim2-select').value;
        const dim2Value = container.querySelector('#dim2-value').value;
        const dim3 = container.querySelector('#dim3-select').value;
        const dim3Value = container.querySelector('#dim3-value').value;
        const dim3Enabled = container.querySelector('#dim3-enable').checked;
        const xAxis = container.querySelector('#x-axis-select').value;

        const summary = container.querySelector('#chart-summary');
        const summaryContent = container.querySelector('#summary-content');

        if (dim1 && dim2 && xAxis) {
          let summaryText = '';

          // å›ºå®šç»´åº¦
          const fixedDims = [];
          if (dim1 && dim1Value) {
            const label = variableOptions.find(opt => opt.value === dim1).label;
            fixedDims.push(`${label}: ${dim1Value}`);
          }
          if (dim2 && dim2Value) {
            const label = variableOptions.find(opt => opt.value === dim2).label;
            fixedDims.push(`${label}: ${dim2Value}`);
          }
          if (dim3Enabled && dim3 && dim3Value) {
            const label = variableOptions.find(opt => opt.value === dim3).label;
            fixedDims.push(`${label}: ${dim3Value}`);
          }

          if (fixedDims.length > 0) {
            summaryText += `<div><strong>å›ºå®šç»´åº¦:</strong> ${fixedDims.join('ã€')}</div>`;
          }

          // Xè½´
          const xAxisLabel = variableOptions.find(opt => opt.value === xAxis).label;
          summaryText += `<div><strong>Xè½´:</strong> ${xAxisLabel}</div>`;

          // å›¾ä¾‹
          const selectedDims = getSelectedDimensions();
          const allUsedDims = [...selectedDims, xAxis];
          const legendDims = variableOptions.filter(opt => !allUsedDims.includes(opt.value));
          if (legendDims.length > 0) {
            summaryText += `<div><strong>å›¾ä¾‹åˆ†ç»„:</strong> ${legendDims.map(d => d.label).join('ã€')}</div>`;
          }

          summaryContent.innerHTML = summaryText;
          summary.style.display = 'block';
        } else {
          summary.style.display = 'none';
        }
      }

      // å¡«å……ç»´åº¦å€¼é€‰é¡¹
      function populateDimensionValues(dimension, selectElement) {
        const values = new Set();

        // ä½¿ç”¨å½“å‰è®¾å¤‡çš„perfRowsæ•°æ®ï¼Œä¸æ˜¯å…¨å±€æ•°æ®
        console.log('å¡«å……ç»´åº¦å€¼é€‰é¡¹:', dimension, 'è®¾å¤‡:', device, 'æ•°æ®é‡:', perfRows.length);

        perfRows.forEach(row => {
          let value;
          switch (dimension) {
            case 'model':
              const remark = row.entry?.base_info?.remark?.trim() || '';
              value = remark ? `${row.model} (${remark})` : row.model;
              break;
            case 'version':
              value = row.version;
              break;
            case 'concurrency':
              value = row.concurrency.toString();
              break;
            case 'token_combination':
              const expectedIn = row.expected_input || row.input_tokens;
              const expectedOut = row.expected_output || row.output_tokens;
              value = `${expectedIn}/${expectedOut}`;
              break;
          }
          if (value) {
            values.add(value);
            console.log(`æ·»åŠ ${dimension}å€¼:`, value);
          }
        });

        console.log(`${dimension}çš„æ‰€æœ‰å€¼:`, Array.from(values));
        selectElement.innerHTML = '<option value="">é€‰æ‹©å€¼...</option>' +
          Array.from(values).sort().map(value =>
            `<option value="${value}">${value}</option>`
          ).join('');
      }

      // ç»´åº¦1é€‰æ‹©äº‹ä»¶
      container.querySelector('#dim1-select').addEventListener('change', function() {
        console.log('ğŸ¯ ç»´åº¦1é€‰æ‹©å˜åŒ–:', this.value);
        const valueGroup = container.querySelector('#dim1-value-group');
        const valueSelect = container.querySelector('#dim1-value');
        const dim2Select = container.querySelector('#dim2-select');

        if (this.value) {
          console.log('ğŸ“Š å¼€å§‹å¡«å……ç»´åº¦1çš„å€¼é€‰é¡¹');
          populateDimensionValues(this.value, valueSelect);
          valueGroup.style.display = 'block';
          dim2Select.disabled = false;
          container.querySelector('#dim1-config').classList.add('active');
          console.log('âœ… ç»´åº¦1é…ç½®å®Œæˆ');
        } else {
          valueGroup.style.display = 'none';
          dim2Select.disabled = true;
          container.querySelector('#dim1-config').classList.remove('active');
        }

        updateAvailableOptions();
      });

      // ç»´åº¦2é€‰æ‹©äº‹ä»¶
      container.querySelector('#dim2-select').addEventListener('change', function() {
        const valueGroup = container.querySelector('#dim2-value-group');
        const valueSelect = container.querySelector('#dim2-value');
        const dim3Enable = container.querySelector('#dim3-enable');

        if (this.value) {
          populateDimensionValues(this.value, valueSelect);
          valueGroup.style.display = 'block';
          dim3Enable.disabled = false;
          container.querySelector('#dim2-config').classList.add('active');
        } else {
          valueGroup.style.display = 'none';
          dim3Enable.disabled = true;
          container.querySelector('#dim2-config').classList.remove('active');
        }

        updateAvailableOptions();
      });

      // ç»´åº¦3å¯ç”¨äº‹ä»¶
      container.querySelector('#dim3-enable').addEventListener('change', function() {
        const dim3Select = container.querySelector('#dim3-select');
        const dim3Config = container.querySelector('#dim3-config');

        if (this.checked) {
          dim3Select.disabled = false;
          dim3Config.classList.remove('disabled');
        } else {
          dim3Select.disabled = true;
          dim3Select.value = '';
          container.querySelector('#dim3-value-group').style.display = 'none';
          dim3Config.classList.add('disabled');
          dim3Config.classList.remove('active');
        }

        updateAvailableOptions();
      });

      // ç»´åº¦3é€‰æ‹©äº‹ä»¶
      container.querySelector('#dim3-select').addEventListener('change', function() {
        const valueGroup = container.querySelector('#dim3-value-group');
        const valueSelect = container.querySelector('#dim3-value');

        if (this.value) {
          populateDimensionValues(this.value, valueSelect);
          valueGroup.style.display = 'block';
          container.querySelector('#dim3-config').classList.add('active');
        } else {
          valueGroup.style.display = 'none';
          container.querySelector('#dim3-config').classList.remove('active');
        }

        updateAvailableOptions();
      });

      // Xè½´é€‰æ‹©äº‹ä»¶
      container.querySelector('#x-axis-select').addEventListener('change', function() {
        if (this.value) {
          container.querySelector('#x-axis-config').classList.add('active');
        } else {
          container.querySelector('#x-axis-config').classList.remove('active');
        }

        updateLegendInfo();

        // ç›´æ¥è§¦å‘å›¾è¡¨æ›´æ–°
        setTimeout(() => {
          triggerChartUpdate();
        }, 100);
      });

      // å€¼é€‰æ‹©äº‹ä»¶
      ['#dim1-value', '#dim2-value', '#dim3-value'].forEach(selector => {
        container.querySelector(selector).addEventListener('change', () => {
          updateSummary();
          // ç›´æ¥è§¦å‘å›¾è¡¨æ›´æ–°
          setTimeout(() => {
            triggerChartUpdate();
          }, 100);
        });
      });

      // ç›´æ¥è§¦å‘å›¾è¡¨æ›´æ–°çš„å‡½æ•°
      function triggerChartUpdate() {
        console.log('ğŸ”„ è§¦å‘å›¾è¡¨æ›´æ–°ï¼Œè®¾å¤‡:', device, 'æ•°æ®é‡:', perfRows.length);
        const deviceKey = String(device).replace(/\s+/g, '-');
        console.log('æŸ¥æ‰¾å›¾è¡¨å®ä¾‹ï¼ŒdeviceKey:', deviceKey);
        console.log('å¯ç”¨çš„å›¾è¡¨å®ä¾‹:', window.chartInstances);

        const chartInstance = window.chartInstances?.[deviceKey]?.configurableChart;
        if (chartInstance) {
          console.log('âœ… æ‰¾åˆ°å›¾è¡¨å®ä¾‹ï¼Œå¼€å§‹æ›´æ–°');
          // ä½¿ç”¨å½“å‰è®¾å¤‡çš„perfRowsï¼Œä¸æ˜¯å…¨å±€æ•°æ®
          updateConfigurableChart(chartInstance, perfRows, device, container);
        } else {
          console.error('âŒ æœªæ‰¾åˆ°å›¾è¡¨å®ä¾‹:', deviceKey);
          console.log('å°è¯•é‡æ–°åˆå§‹åŒ–å›¾è¡¨...');
          // å°è¯•é‡æ–°æ‰¾åˆ°å›¾è¡¨å®¹å™¨å¹¶åˆå§‹åŒ–
          const chartContainer = container.querySelector('.chart-container');
          if (chartContainer) {
            const newChart = echarts.init(chartContainer);
            if (!window.chartInstances) window.chartInstances = {};
            if (!window.chartInstances[deviceKey]) window.chartInstances[deviceKey] = {};
            window.chartInstances[deviceKey].configurableChart = newChart;
            updateConfigurableChart(newChart, perfRows, device, container);
          }
        }
      }

      // åˆå§‹åŒ–çŠ¶æ€
      container.querySelector('#dim3-config').classList.add('disabled');

      // æ ‡è®°å®¹å™¨ï¼Œç¨åè®¾ç½®é»˜è®¤é…ç½®
      container.dataset.device = device;
      container.dataset.needsDefaultConfig = 'true';

      return container;
    }

    // è®¾ç½®é»˜è®¤é…ç½®
    function setDefaultConfiguration(container, device, perfRows) {
      console.log('ğŸ¯ è®¾ç½®é»˜è®¤é…ç½®ï¼Œè®¾å¤‡:', device);

      // è·å–è®¾å¤‡çš„å¯ç”¨æ•°æ®
      const models = [...new Set(perfRows.map(r => r.model))].sort();
      const versions = [...new Set(perfRows.map(r => r.version))].sort(compareVersionAsc);

      console.log('å¯ç”¨æ¨¡å‹:', models);
      console.log('å¯ç”¨ç‰ˆæœ¬:', versions);

      let defaultConfig = {};

      // æ ¹æ®è®¾å¤‡è®¾ç½®ä¸åŒçš„é»˜è®¤é…ç½®
      if (device.includes('s4000')) {
        // s4000è®¾å¤‡ï¼šæ¨¡å‹é€‰æ‹©671b(6core)ï¼Œç‰ˆæœ¬é€‰æ‹©æœ€æ–°ç‰ˆæœ¬ï¼ŒXè½´é€‰æ‹©å¹¶å‘æ•°
        const target671b = models.find(m => m.includes('671b') && m.includes('6core'));
        if (target671b) {
          defaultConfig = {
            dim1: { dimension: 'model', value: target671b },
            dim2: { dimension: 'version', value: versions[versions.length - 1] }, // æœ€æ–°ç‰ˆæœ¬
            xAxis: 'concurrency'
          };
        }
      } else {
        // å…¶ä»–è®¾å¤‡ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å‹
        if (models.length > 0) {
          defaultConfig = {
            dim1: { dimension: 'model', value: models[0] },
            dim2: { dimension: 'version', value: versions[versions.length - 1] }, // æœ€æ–°ç‰ˆæœ¬
            xAxis: 'concurrency'
          };
        }
      }

      console.log('é»˜è®¤é…ç½®:', defaultConfig);

      // åº”ç”¨é»˜è®¤é…ç½®
      if (defaultConfig.dim1) {
        const dim1Select = container.querySelector('#dim1-select');
        const dim1ValueSelect = container.querySelector('#dim1-value');

        // è®¾ç½®ç»´åº¦1
        console.log('ğŸ”§ è®¾ç½®ç»´åº¦1:', defaultConfig.dim1.dimension);
        dim1Select.value = defaultConfig.dim1.dimension;

        // æ‰‹åŠ¨è§¦å‘changeäº‹ä»¶
        const changeEvent = new Event('change', { bubbles: true });
        dim1Select.dispatchEvent(changeEvent);
        console.log('âœ… ç»´åº¦1äº‹ä»¶å·²è§¦å‘');

        // ç­‰å¾…ç»´åº¦1çš„å€¼é€‰é¡¹åŠ è½½å®Œæˆ
        setTimeout(() => {
          console.log('ğŸ” æ£€æŸ¥ç»´åº¦1å€¼é€‰é¡¹æ˜¯å¦å·²åŠ è½½');
          console.log('å¯ç”¨é€‰é¡¹:', Array.from(dim1ValueSelect.options).map(o => o.value));

          if (dim1ValueSelect.querySelector(`option[value="${defaultConfig.dim1.value}"]`)) {
            console.log('ğŸ”§ è®¾ç½®ç»´åº¦1å€¼:', defaultConfig.dim1.value);
            dim1ValueSelect.value = defaultConfig.dim1.value;

            const valueChangeEvent = new Event('change', { bubbles: true });
            dim1ValueSelect.dispatchEvent(valueChangeEvent);
            console.log('âœ… ç»´åº¦1å€¼å·²è®¾ç½®:', defaultConfig.dim1.value);
          } else {
            console.log('âŒ ç»´åº¦1å€¼ä¸å­˜åœ¨:', defaultConfig.dim1.value);
            console.log('å°è¯•ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨å€¼');
            if (dim1ValueSelect.options.length > 1) {
              dim1ValueSelect.value = dim1ValueSelect.options[1].value;
              dim1ValueSelect.dispatchEvent(new Event('change', { bubbles: true }));
              console.log('âœ… ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨å€¼:', dim1ValueSelect.value);
            }
          }

          // è®¾ç½®ç»´åº¦2
          if (defaultConfig.dim2) {
            const dim2Select = container.querySelector('#dim2-select');
            const dim2ValueSelect = container.querySelector('#dim2-value');

            console.log('ğŸ”§ è®¾ç½®ç»´åº¦2:', defaultConfig.dim2.dimension);
            dim2Select.value = defaultConfig.dim2.dimension;
            dim2Select.dispatchEvent(new Event('change', { bubbles: true }));
            console.log('âœ… ç»´åº¦2å·²è®¾ç½®:', defaultConfig.dim2.dimension);

            setTimeout(() => {
              console.log('ğŸ” æ£€æŸ¥ç»´åº¦2å€¼é€‰é¡¹');
              if (dim2ValueSelect.querySelector(`option[value="${defaultConfig.dim2.value}"]`)) {
                console.log('ğŸ”§ è®¾ç½®ç»´åº¦2å€¼:', defaultConfig.dim2.value);
                dim2ValueSelect.value = defaultConfig.dim2.value;
                dim2ValueSelect.dispatchEvent(new Event('change', { bubbles: true }));
                console.log('âœ… ç»´åº¦2å€¼å·²è®¾ç½®:', defaultConfig.dim2.value);
              } else {
                console.log('âŒ ç»´åº¦2å€¼ä¸å­˜åœ¨:', defaultConfig.dim2.value);
                if (dim2ValueSelect.options.length > 1) {
                  dim2ValueSelect.value = dim2ValueSelect.options[1].value;
                  dim2ValueSelect.dispatchEvent(new Event('change', { bubbles: true }));
                  console.log('âœ… ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨å€¼:', dim2ValueSelect.value);
                }
              }

              // è®¾ç½®Xè½´
              if (defaultConfig.xAxis) {
                const xAxisSelect = container.querySelector('#x-axis-select');
                setTimeout(() => {
                  console.log('ğŸ”§ è®¾ç½®Xè½´:', defaultConfig.xAxis);
                  if (xAxisSelect.querySelector(`option[value="${defaultConfig.xAxis}"]`)) {
                    xAxisSelect.value = defaultConfig.xAxis;
                    xAxisSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log('âœ… Xè½´å·²è®¾ç½®:', defaultConfig.xAxis);

                    // æœ€åè§¦å‘ä¸€æ¬¡å›¾è¡¨æ›´æ–°
                    setTimeout(() => {
                      console.log('ğŸ¯ è§¦å‘æœ€ç»ˆå›¾è¡¨æ›´æ–°');
                      const deviceKey = String(device).replace(/\s+/g, '-');
                      const chartInstance = window.chartInstances?.[deviceKey]?.configurableChart;
                      const perfRows = window.devicePerfRows?.[deviceKey] || [];

                      if (chartInstance && perfRows.length > 0) {
                        updateConfigurableChart(chartInstance, perfRows, device, container);
                        console.log('âœ… é»˜è®¤å›¾è¡¨æ›´æ–°å®Œæˆ');
                      } else {
                        console.log('âŒ å›¾è¡¨å®ä¾‹æˆ–æ•°æ®ä¸å­˜åœ¨');
                      }
                    }, 200);
                  } else {
                    console.log('âŒ Xè½´é€‰é¡¹ä¸å­˜åœ¨:', defaultConfig.xAxis);
                  }
                }, 100);
              }
            }, 300);
          }
        }, 200);
      }
    }

    // åˆ›å»ºæ€§èƒ½æµ‹è¯•ç­›é€‰å™¨å®¹å™¨
    function createPerfFilterContainer(perfRows, device, allData) {
      const container = document.createElement('div');
      container.className = 'filter-container';

      // è·å–æ¨¡å‹ä¿¡æ¯ï¼ŒåŒ…å«å¤‡æ³¨ï¼ŒæŒ‰model+remarkç»„åˆåˆ†ç»„
      const modelCombinations = new Map();
      perfRows.forEach(row => {
        const model = row.model;
        const remark = row.entry?.base_info?.remark?.trim() || '';
        const combinationKey = remark ? `${model}_${remark}` : model;
        const displayName = remark ? `${model} (${remark})` : model;

        if (!modelCombinations.has(combinationKey)) {
          modelCombinations.set(combinationKey, {
            baseModel: model,
            displayName: displayName,
            remark: remark
          });
        }
      });

      // è·å–æ‰€æœ‰å”¯ä¸€çš„æ¨¡å‹ç»„åˆ
      const models = Array.from(modelCombinations.keys()).sort();
      const versions = [...new Set(perfRows.map(r => r.version))].sort(compareVersionAsc);
      const concurrencies = [...new Set(perfRows.map(r => r.concurrency))].sort((a, b) => a - b);

      // åˆå¹¶è¾“å…¥è¾“å‡ºtokensä¸ºç»„åˆ (ä½¿ç”¨expected_inputå’Œexpected_output)
      const tokenCombinations = [...new Set(perfRows.map(r =>
        `${r.expected_input || r.input_tokens}/${r.expected_output || r.output_tokens}`
      ))].sort((a, b) => {
        const [aIn, aOut] = a.split('/').map(Number);
        const [bIn, bOut] = b.split('/').map(Number);
        return (aIn + aOut) - (bIn + bOut);
      });

      container.innerHTML = `
        <div class="filter-title">
          ğŸ” æ•°æ®ç­›é€‰å™¨ <small style="color: #6b7280; font-weight: normal;">(ç‚¹å‡»å±•å¼€å¤šé€‰)</small>
        </div>
        <div class="filter-grid">
          <div class="filter-group">
            <label>æ¨¡å‹</label>
            <select multiple data-filter="model">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${models.map(modelKey => {
                const modelInfo = modelCombinations.get(modelKey);
                return `<option value="${modelKey}" selected>${modelInfo.displayName}</option>`;
              }).join('')}
            </select>
          </div>
          <div class="filter-group">
            <label>ç‰ˆæœ¬</label>
            <select multiple data-filter="version">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${versions.map(v => `<option value="${v}" selected>${v}</option>`).join('')}
            </select>
          </div>
          <div class="filter-group">
            <label>å¹¶å‘æ•°</label>
            <select multiple data-filter="concurrency">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${concurrencies.map(c => `<option value="${c}" selected>${c}</option>`).join('')}
            </select>
          </div>
          <div class="filter-group">
            <label>è¾“å…¥/è¾“å‡º Tokens</label>
            <select multiple data-filter="token_combination">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${tokenCombinations.map(combo => `<option value="${combo}" selected>${combo}</option>`).join('')}
            </select>
          </div>
        </div>
      `;

      // æ·»åŠ é€‰ä¸­é¡¹è®¡æ•°åŠŸèƒ½å’Œå…¨é€‰é€»è¾‘
      const selects = container.querySelectorAll('select[multiple]');
      selects.forEach(select => {
        const updateCount = () => {
          const selectedCount = select.selectedOptions.length;
          const totalCount = select.options.length;
          const group = select.closest('.filter-group');

          if (selectedCount === totalCount) {
            group.classList.remove('has-selection');
          } else {
            group.classList.add('has-selection');
            group.setAttribute('data-selected-count', selectedCount);
          }
        };

        // å…¨é€‰é€»è¾‘å¤„ç†
        select.addEventListener('change', (e) => {
          const allOption = select.querySelector('option[value="__ALL__"]');
          const otherOptions = Array.from(select.options).filter(opt => opt.value !== '__ALL__');

          if (e.target.value === '__ALL__') {
            if (allOption.selected) {
              // é€‰ä¸­å…¨é€‰æ—¶ï¼Œé€‰ä¸­æ‰€æœ‰å…¶ä»–é€‰é¡¹
              otherOptions.forEach(opt => opt.selected = true);
            } else {
              // å–æ¶ˆå…¨é€‰æ—¶ï¼Œå–æ¶ˆæ‰€æœ‰å…¶ä»–é€‰é¡¹
              otherOptions.forEach(opt => opt.selected = false);
            }
          } else {
            // é€‰æ‹©å…·ä½“é€‰é¡¹æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å…¨é€‰çŠ¶æ€
            const allOthersSelected = otherOptions.every(opt => opt.selected);
            const anyOtherSelected = otherOptions.some(opt => opt.selected);

            if (allOthersSelected) {
              allOption.selected = true;
            } else if (!anyOtherSelected) {
              allOption.selected = false;
            }
          }

          updateCount();
        });

        updateCount(); // åˆå§‹åŒ–
      });

      return container;
    }

    // åˆ›å»ºç²¾åº¦æµ‹è¯•ç­›é€‰å™¨å®¹å™¨
    function createAccFilterContainer(accRows, device, allData) {
      const container = document.createElement('div');
      container.className = 'filter-container';

      // è·å–æ¨¡å‹ä¿¡æ¯ï¼ŒåŒ…å«å¤‡æ³¨ï¼ŒæŒ‰model+remarkç»„åˆåˆ†ç»„
      const modelCombinations = new Map();
      accRows.forEach(row => {
        const model = row.model;
        const remark = row.entry?.base_info?.remark?.trim() || '';
        const combinationKey = remark ? `${model}_${remark}` : model;
        const displayName = remark ? `${model} (${remark})` : model;

        if (!modelCombinations.has(combinationKey)) {
          modelCombinations.set(combinationKey, {
            baseModel: model,
            displayName: displayName,
            remark: remark
          });
        }
      });

      // è·å–æ‰€æœ‰å”¯ä¸€çš„æ¨¡å‹ç»„åˆå’Œç‰ˆæœ¬
      const models = Array.from(modelCombinations.keys()).sort();
      const versions = [...new Set(accRows.map(r => r.version))].sort(compareVersionAsc);

      container.innerHTML = `
        <div class="filter-title">
          ğŸ” ç²¾åº¦æµ‹è¯•ç­›é€‰å™¨ <small style="color: #6b7280; font-weight: normal;">(ç‚¹å‡»å±•å¼€å¤šé€‰)</small>
        </div>
        <div class="filter-grid">
          <div class="filter-group">
            <label>æ¨¡å‹</label>
            <select multiple data-filter="model">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${models.map(modelKey => {
                const modelInfo = modelCombinations.get(modelKey);
                return `<option value="${modelKey}" selected>${modelInfo.displayName}</option>`;
              }).join('')}
            </select>
          </div>
          <div class="filter-group">
            <label>ç‰ˆæœ¬</label>
            <select multiple data-filter="version">
              <option value="__ALL__" selected>ğŸ”˜ å…¨é€‰</option>
              ${versions.map(v => `<option value="${v}" selected>${v}</option>`).join('')}
            </select>
          </div>
        </div>
      `;

      // æ·»åŠ é€‰ä¸­é¡¹è®¡æ•°åŠŸèƒ½å’Œå…¨é€‰é€»è¾‘
      const selects = container.querySelectorAll('select[multiple]');
      selects.forEach(select => {
        const updateCount = () => {
          const selectedCount = select.selectedOptions.length;
          const totalCount = select.options.length;
          const group = select.closest('.filter-group');

          if (selectedCount === totalCount) {
            group.classList.remove('has-selection');
          } else {
            group.classList.add('has-selection');
            group.setAttribute('data-selected-count', selectedCount);
          }
        };

        // å…¨é€‰é€»è¾‘å¤„ç†
        select.addEventListener('change', (e) => {
          const allOption = select.querySelector('option[value="__ALL__"]');
          const otherOptions = Array.from(select.options).filter(opt => opt.value !== '__ALL__');

          if (e.target.value === '__ALL__') {
            if (allOption.selected) {
              // é€‰ä¸­å…¨é€‰æ—¶ï¼Œé€‰ä¸­æ‰€æœ‰å…¶ä»–é€‰é¡¹
              otherOptions.forEach(opt => opt.selected = true);
            } else {
              // å–æ¶ˆå…¨é€‰æ—¶ï¼Œå–æ¶ˆæ‰€æœ‰å…¶ä»–é€‰é¡¹
              otherOptions.forEach(opt => opt.selected = false);
            }
          } else {
            // é€‰æ‹©å…·ä½“é€‰é¡¹æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å…¨é€‰çŠ¶æ€
            const allOthersSelected = otherOptions.every(opt => opt.selected);
            const anyOtherSelected = otherOptions.some(opt => opt.selected);

            if (allOthersSelected) {
              allOption.selected = true;
            } else if (!anyOtherSelected) {
              allOption.selected = false;
            }
          }

          updateCount();
        });

        updateCount(); // åˆå§‹åŒ–
      });

      return container;
    }

    // åˆ›å»ºæ•°æ®è¡¨æ ¼ (é»˜è®¤éšè—)
    function createDataTable(perfRows, device) {
      const container = document.createElement('div');
      container.className = 'data-table-container';
      container.id = `table-${device.replace(/\s+/g, '-')}`;
      container.style.display = 'none'; // é»˜è®¤éšè—è¡¨æ ¼

      const table = document.createElement('table');
      table.className = 'data-table';

      table.innerHTML = `
        <thead>
          <tr>
            <th>æ¨¡å‹</th>
            <th>ç‰ˆæœ¬</th>
            <th>å¹¶å‘æ•°</th>
            <th>è¾“å…¥Tokens</th>
            <th>è¾“å‡ºTokens</th>
            <th>ååç‡ (output)</th>
            <th>æ€»ååç‡</th>
            <th>å¹³å‡TTFT (ms)</th>
            <th>P99 TTFT (ms)</th>
          </tr>
        </thead>
        <tbody>
          ${perfRows.map(row => `
            <tr>
              <td>${row.model}</td>
              <td>${row.version}</td>
              <td class="number">${row.concurrency}</td>
              <td class="number">${row.expected_input || row.input_tokens}</td>
              <td class="number">${row.expected_output || row.output_tokens}</td>
              <td class="number">${row.output_throughput?.toFixed(2) || '-'}</td>
              <td class="number">${row.total_throughput?.toFixed(2) || '-'}</td>
              <td class="number">${row.avg_ttft?.toFixed(2) || '-'}</td>
              <td class="number">${row.p99_ttft?.toFixed(2) || '-'}</td>
            </tr>
          `).join('')}
        </tbody>
      `;

      container.appendChild(table);
      return container;
    }
    async function fetchAllResults() {
      const now = Date.now();
      const indexResp = await fetch(`./results/index.json?t=${now}`);
      if (!indexResp.ok) throw new Error("âŒ æ— æ³•åŠ è½½ index.json æ–‡ä»¶");
      const fileList = await indexResp.json();
      const allData = [];
      for (const file of fileList) {
        try {
          const resp = await fetch(`./results/${file}?t=${now}`);
          const data = await resp.json();
          allData.push(data);
        } catch (err) {
          console.error(`è·³è¿‡æ— æ³•åŠ è½½çš„æ–‡ä»¶: ${file}`, err);
        }
      }
      return allData;
    }
    function getSummaryData(perfRows, accRows) {
      let maxOutput = null, minTTFT = null, latestAcc = null;
      if (perfRows.length > 0) {
        maxOutput = Math.max(...perfRows.map(r=>r.output_throughput||0));
        minTTFT = Math.min(...perfRows.map(r=>r.avg_ttft||1e12));
      }
      if (accRows.length > 0) {
        latestAcc = accRows[accRows.length-1]?.score;
      }
      return { maxOutput, minTTFT, latestAcc };
    }
    function getDevicePriority(device) {
      const deviceLower = device.toLowerCase();
      if (deviceLower.includes('000')) return 1;       // Sç³»åˆ—ä¼˜å…ˆ
      if (deviceLower.includes('tiansi')) return 2;  // å¤©æ€å…¶æ¬¡
      if (deviceLower.includes('model')) return 3;   // Modelç¬¬ä¸‰
      if (deviceLower.includes('book')) return 4;    // Bookæœ€å
      return 5;                                      // å…¶ä»–è®¾å¤‡
    }
    function renderGroupedResults(data) {
      const app = document.getElementById("app");
      app.innerHTML = "";
      const grouped = {};
      for (const entry of data) {
        const device = entry.base_info?.device || "æœªçŸ¥è®¾å¤‡";
        const version = entry.base_info?.version || "0.0.0";
        const baseModel = entry.base_info?.model || entry.model_name || "unknown";
        const remark = entry.base_info?.remark?.trim() || '';
        // ä½¿ç”¨æ¨¡å‹+remarkä½œä¸ºå”¯ä¸€æ ‡è¯†
        const model = remark ? `${baseModel}_${remark}` : baseModel;

        if (!grouped[device]) grouped[device] = {};
        if (!grouped[device][version]) grouped[device][version] = {};
        if (!grouped[device][version][model]) grouped[device][version][model] = [];
        grouped[device][version][model].push(entry);
      }
      // æŒ‰ä¼˜å…ˆçº§æ’åºè®¾å¤‡
      const sortedDevices = Object.keys(grouped).sort((a, b) => {
        const priorityA = getDevicePriority(a);
        const priorityB = getDevicePriority(b);
        if (priorityA === priorityB) {
          return a.localeCompare(b); // åŒä¼˜å…ˆçº§æŒ‰å­—æ¯é¡ºåº
        }
        return priorityA - priorityB;
      });
      // ä½¿ç”¨æ’åºåçš„è®¾å¤‡åˆ—è¡¨è¿›è¡Œæ¸²æŸ“
      for (const device of sortedDevices) {
        const versions = grouped[device];
        const groupDiv = document.createElement("div");
        groupDiv.className = "device-group";
        groupDiv.innerHTML = `<div class="device-title">ğŸ–¥ï¸ è®¾å¤‡: <code>${device}</code></div>`;
        let perfRows = [], accRows = [];
        for (const version of Object.keys(versions)) {
          for (const modelKey of Object.keys(versions[version])) {
            for (const entry of versions[version][modelKey]) {
              // ä½¿ç”¨åŸå§‹çš„baseModelï¼Œä¸æ˜¯ç»„åˆçš„modelKey
              const baseModel = entry.base_info?.model || entry.model_name || "unknown";

              const bench = entry.tests?.find(t => t.test_type === "benchmark");
              if (bench) for (const r of bench.results || []) {
                perfRows.push({
                  ...r,
                  model: baseModel,  // ä½¿ç”¨åŸå§‹æ¨¡å‹å
                  version,
                  entry: entry  // ä¿å­˜å®Œæ•´çš„entryä¿¡æ¯ï¼Œç”¨äºè·å–remarkå’Œtokensä¿¡æ¯
                });
              }
              const acc = entry.tests?.find(t => t.test_type === "accuracy");
              if (acc && acc.datasets && acc.datasets[0]?.metrics?.[0]) {
                const score = acc.datasets[0].metrics[0].score;
                console.log('æ·»åŠ ç²¾åº¦æ•°æ®:', {
                  model: baseModel,
                  version,
                  score,
                  remark: entry.base_info?.remark
                });
                accRows.push({
                  model: baseModel,  // ä½¿ç”¨åŸå§‹æ¨¡å‹å
                  version,
                  score: score,
                  entry: entry  // ä¿å­˜å®Œæ•´çš„entryä¿¡æ¯ï¼Œç”¨äºè·å–remark
                });
              }
            }
          }
        }

        console.log(`è®¾å¤‡ ${device} çš„æ€§èƒ½æ•°æ®:`, perfRows.length, 'æ¡');
        console.log(`è®¾å¤‡ ${device} çš„ç²¾åº¦æ•°æ®:`, accRows.length, 'æ¡');

        // è°ƒè¯•ï¼šæ˜¾ç¤ºæ‰€æœ‰æ¨¡å‹ç»„åˆ
        const uniqueModels = [...new Set(perfRows.map(r => {
          const remark = r.entry?.base_info?.remark?.trim() || '';
          return remark ? `${r.model} (${remark})` : r.model;
        }))];
        console.log(`è®¾å¤‡ ${device} çš„æ¨¡å‹ç»„åˆ:`, uniqueModels);

        // è°ƒè¯•ï¼šæ˜¾ç¤ºæ•°æ®åˆ†å¸ƒ
        const dataDistribution = {};
        perfRows.forEach(r => {
          const remark = r.entry?.base_info?.remark?.trim() || '';
          const modelDisplay = remark ? `${r.model} (${remark})` : r.model;
          const key = `${modelDisplay}-${r.version}-${r.concurrency}-${r.expected_input || r.input_tokens}/${r.expected_output || r.output_tokens}`;
          dataDistribution[key] = (dataDistribution[key] || 0) + 1;
        });
        console.log(`è®¾å¤‡ ${device} çš„æ•°æ®åˆ†å¸ƒ:`, dataDistribution);

        // æ±‡æ€»å¡ç‰‡å·²ç§»é™¤

        if (perfRows.length > 0) {
          // åˆ›å»ºé…ç½®åŒ–å›¾è¡¨å±•ç¤ºåŒºåŸŸ
          const configuredChartDiv = document.createElement('div');
          configuredChartDiv.className = 'chart-wrap';
          configuredChartDiv.innerHTML = `<div class="chart-title">ğŸ“ˆ æ€§èƒ½å¯¹æ¯”å›¾è¡¨</div>`;
          groupDiv.appendChild(configuredChartDiv);

          // åˆ›å»ºå›¾è¡¨é…ç½®å™¨ï¼ˆæ©™è‰²ï¼‰- æ”¾åœ¨æ€§èƒ½å›¾è¡¨å’Œæ€§èƒ½æµ‹è¯•å›¾è¡¨ä¹‹é—´
          const chartConfigContainer = createChartConfigContainer(perfRows, device);
          groupDiv.appendChild(chartConfigContainer);

          // åˆ›å»ºæ•°æ®è¡¨æ ¼
          const tableContainer = createDataTable(perfRows, device);
          groupDiv.appendChild(tableContainer);

          // åˆå§‹åŒ–é…ç½®åŒ–å›¾è¡¨
          console.log('ğŸš€ åˆå§‹åŒ–é…ç½®åŒ–å›¾è¡¨ï¼Œè®¾å¤‡:', device);
          initConfigurableChart(perfRows, configuredChartDiv, null, device, chartConfigContainer);

          // è®¾ç½®å…¨å±€æ›´æ–°å‡½æ•°
          if (!window.updateConfigurableChartForDevice) {
            window.updateConfigurableChartForDevice = function(targetDevice) {
              console.log('å…¨å±€æ›´æ–°å‡½æ•°è¢«è°ƒç”¨:', targetDevice);
              // æ‰¾åˆ°æ‰€æœ‰è®¾å¤‡çš„å›¾è¡¨å®ä¾‹å¹¶æ›´æ–°å¯¹åº”çš„è®¾å¤‡
              if (window.chartInstances) {
                Object.keys(window.chartInstances).forEach(deviceKey => {
                  const deviceName = deviceKey.replace(/-/g, ' ');
                  if (deviceName === String(targetDevice) || deviceKey === String(targetDevice).replace(/\s+/g, '-')) {
                    const chartInstance = window.chartInstances[deviceKey]?.configurableChart;
                    if (chartInstance) {
                      console.log('æ›´æ–°è®¾å¤‡å›¾è¡¨:', deviceName);
                      // è·å–è¯¥è®¾å¤‡çš„æ•°æ®å’Œé…ç½®å®¹å™¨
                      const devicePerfRows = window.devicePerfRows?.[deviceKey] || window.currentPerfRows || [];
                      const configContainer = document.querySelector(`[data-device="${deviceName}"] .chart-config-container`) ||
                                            document.querySelector('.chart-config-container');
                      updateConfigurableChart(chartInstance, devicePerfRows, deviceName, configContainer);
                    }
                  }
                });
              }
            };
          }

          // ä¿å­˜å½“å‰è®¾å¤‡çš„æ•°æ®
          const deviceKey = String(device).replace(/\s+/g, '-');
          if (!window.devicePerfRows) window.devicePerfRows = {};
          window.devicePerfRows[deviceKey] = perfRows;

        // ç²¾åº¦æµ‹è¯•åŒºåŸŸ
        if (accRows.length > 0) {
          // ç²¾åº¦å›¾è¡¨
          const accDiv = document.createElement('div');
          accDiv.className = 'chart-wrap';
          accDiv.innerHTML = `<div class="chart-title">ğŸ¯ ç²¾åº¦æµ‹è¯•ç»“æœ</div>`;
          const accuracyCanvas = document.createElement("canvas");
          accDiv.appendChild(accuracyCanvas);
          groupDiv.appendChild(accDiv);

          // ç²¾åº¦æµ‹è¯•ç­›é€‰å™¨ï¼ˆæ”¾åœ¨ç²¾åº¦å›¾è¡¨ä¸‹é¢ï¼‰
          const accFilterContainer = createAccFilterContainer(accRows, device, data);
          groupDiv.appendChild(accFilterContainer);

          // åˆå§‹åŒ–ç²¾åº¦å›¾è¡¨
          initAccuracyChart(accuracyCanvas, accRows, device, accFilterContainer);
        }

          // ç²¾åº¦å›¾è¡¨å·²åœ¨ä¸Šé¢åˆå§‹åŒ–
        }
        // æ˜ç»†è¡¨æ ¼
        for (const version of Object.keys(versions).sort(compareVersionDesc)) {
          const versionDiv = document.createElement("div");
          versionDiv.className = "version-section";
          versionDiv.innerHTML = `<h3>ğŸ“¦ ç‰ˆæœ¬: <code>${version}</code></h3>`;
          for (const [model, entries] of Object.entries(versions[version])) {
            for (const entry of entries) {
              const modelDiv = document.createElement("div");
              modelDiv.className = "model-block";
              modelDiv.innerHTML = `<h4>ğŸ¤– æ¨¡å‹: <code>${model} (${entry.base_info?.remark?.trim() || '6core'})</code></h4>`;
              const bench = entry.tests?.find(t => t.test_type === "benchmark");
              if (bench) {
                let html = `<h5>ğŸš€ æ€§èƒ½æµ‹è¯•</h5><table><tr>
                  <th>å¹¶å‘æ•°</th><th>è¾“å…¥Tokens</th><th>è¾“å‡ºTokens</th>
                  <th>ååç‡ (output)</th><th>æ€»ååç‡</th><th>å¹³å‡TTFT (ms)</th>
                </tr>`;
                for (const r of bench.results || []) {
                  html += `<tr>
                    <td>${r.concurrency}</td><td>${r.expected_input || r.input_tokens}</td><td>${r.expected_output || r.output_tokens}</td>
                    <td>${r.output_throughput}</td><td>${r.total_throughput}</td><td>${r.avg_ttft}</td>
                  </tr>`;
                }
                html += `</table>`;
                modelDiv.innerHTML += html;
              }
              const acc = entry.tests?.find(t => t.test_type === "accuracy");
              if (acc) {
                let html = `<h5>ğŸ¯ ç²¾åº¦æµ‹è¯•</h5><table><tr>
                  <th>æ•°æ®é›†</th><th>å¹³å‡å‡†ç¡®ç‡</th><th>æ ·æœ¬æ•°</th>
                </tr>`;
                for (const d of acc.datasets || []) {
                  const metric = d.metrics?.[0];
                  html += `<tr>
                    <td>${d.dataset_pretty_name || d.name}</td>
                    <td>${(metric?.score * 100).toFixed(2)}%</td>
                    <td>${metric?.num}</td>
                  </tr>`;
                }
                html += `</table>`;
                modelDiv.innerHTML += html;
              }
              versionDiv.appendChild(modelDiv);
            }
          }
          groupDiv.appendChild(versionDiv);
        }
        app.appendChild(groupDiv);
      }
    }
    // åˆå§‹åŒ–é…ç½®åŒ–å›¾è¡¨
    function initConfigurableChart(perfRows, chartContainer, data, device, chartConfigContainer) {
      console.log('ğŸ“Š åˆå§‹åŒ–é…ç½®åŒ–å›¾è¡¨å‡½æ•°è¢«è°ƒç”¨');
      console.log('å‚æ•°:', { perfRows: perfRows.length, device, chartContainer: !!chartContainer, chartConfigContainer: !!chartConfigContainer });

      // ä¿å­˜å½“å‰æ•°æ®åˆ°å…¨å±€å˜é‡
      window.currentPerfRows = perfRows;

      // åˆ›å»ºå›¾è¡¨å®¹å™¨
      const chartDiv = document.createElement('div');
      chartDiv.className = 'chart-container';
      chartDiv.style.cssText = 'height: 500px; width: 1000px; min-width: 1000px;';
      chartContainer.appendChild(chartDiv);

      // åˆå§‹åŒ–EChartså®ä¾‹
      const chart = echarts.init(chartDiv);

      // ä¿å­˜å›¾è¡¨å®ä¾‹å’Œæ•°æ®
      const deviceKey = String(device).replace(/\s+/g, '-');
      console.log('ğŸ’¾ ä¿å­˜å›¾è¡¨å®ä¾‹ï¼ŒdeviceKey:', deviceKey);
      if (!window.chartInstances) window.chartInstances = {};
      if (!window.chartInstances[deviceKey]) window.chartInstances[deviceKey] = {};
      if (!window.devicePerfRows) window.devicePerfRows = {};

      window.chartInstances[deviceKey].configurableChart = chart;
      window.devicePerfRows[deviceKey] = perfRows;

      console.log('âœ… å›¾è¡¨å®ä¾‹å’Œæ•°æ®å·²ä¿å­˜:', {
        chartInstances: Object.keys(window.chartInstances),
        devicePerfRows: Object.keys(window.devicePerfRows)
      });

      // åˆå§‹æ¸²æŸ“
      updateConfigurableChart(chart, perfRows, device, chartConfigContainer);

      // å»¶è¿Ÿè®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼Œç¡®ä¿DOMå·²å®Œå…¨åŠ è½½
      setTimeout(() => {
        setupConfigurableChartListeners(chart, perfRows, device, chartConfigContainer).then(() => {
          // è®¾ç½®é»˜è®¤é…ç½®
          if (chartConfigContainer && chartConfigContainer.dataset.needsDefaultConfig === 'true') {
            console.log('ğŸ¯ è§¦å‘é»˜è®¤é…ç½®è®¾ç½®');
            setTimeout(() => {
              setDefaultConfiguration(chartConfigContainer, device, perfRows);
              chartConfigContainer.dataset.needsDefaultConfig = 'false';
            }, 300);
          }
        });
      }, 100);
    }

    // æ›´æ–°é…ç½®åŒ–å›¾è¡¨
    function updateConfigurableChart(chart, perfRows, device, configContainer = null) {
      console.log('ğŸ”„ æ›´æ–°é…ç½®åŒ–å›¾è¡¨', device, perfRows?.length || 0);

      // å‚æ•°éªŒè¯
      if (!chart) {
        console.error('âŒ å›¾è¡¨å®ä¾‹ä¸å­˜åœ¨');
        return;
      }

      if (!perfRows || perfRows.length === 0) {
        console.error('âŒ æ€§èƒ½æ•°æ®ä¸ºç©º');
        return;
      }

      // å¦‚æœæ²¡æœ‰ä¼ å…¥é…ç½®å®¹å™¨ï¼Œå°è¯•æŸ¥æ‰¾
      if (!configContainer) {
        configContainer = findConfigContainer(device);
        if (!configContainer) {
          console.error('âŒ æ‰¾ä¸åˆ°é…ç½®å®¹å™¨:', device);
          return;
        }
      }

      try {
        // è·å–å›¾è¡¨é…ç½®
        const config = getChartConfigFromContainer(device, configContainer);
        console.log('ğŸ“Š å›¾è¡¨é…ç½®:', config);

        // é˜²æ­¢é‡å¤æ›´æ–°
        const deviceKey = String(device).replace(/\s+/g, '-');
        const updateKey = `${deviceKey}_${Date.now()}`;

        if (window.chartUpdateInProgress && window.chartUpdateInProgress[deviceKey]) {
          console.log('âš ï¸ å›¾è¡¨æ›´æ–°è¿›è¡Œä¸­ï¼Œè·³è¿‡é‡å¤æ›´æ–°');
          return;
        }

        if (!window.chartUpdateInProgress) window.chartUpdateInProgress = {};
        window.chartUpdateInProgress[deviceKey] = updateKey;

        if (!config.isValid) {
        // æ˜¾ç¤ºé…ç½®æç¤º
        console.log('âŒ é…ç½®ä¸å®Œæ•´ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯');
        chart.setOption({
          backgroundColor: '#fff',
          title: {
            text: 'è¯·å®Œæˆå›¾è¡¨é…ç½®',
            subtext: 'æŒ‰é¡ºåºé€‰æ‹©å›ºå®šç»´åº¦å’ŒXè½´',
            left: 'center',
            top: 'middle',
            textStyle: {
              color: '#666',
              fontSize: 18
            },
            subtextStyle: {
              color: '#999',
              fontSize: 14
            }
          }
        });
        return;
      }

        console.log('âœ… é…ç½®å®Œæ•´ï¼Œå¼€å§‹ç”Ÿæˆå›¾è¡¨æ•°æ®');

        // æ ¹æ®é…ç½®ç”Ÿæˆå›¾è¡¨æ•°æ®
        const chartData = generateChartData(perfRows, config);
        console.log('å›¾è¡¨æ•°æ®:', chartData);

        // ç”Ÿæˆå›¾è¡¨é€‰é¡¹
        const option = generateChartOption(chartData, config);
        console.log('å›¾è¡¨é€‰é¡¹:', option);

        // æ¸²æŸ“å›¾è¡¨
        chart.setOption(option, true);
        console.log('âœ… å›¾è¡¨æ¸²æŸ“å®Œæˆ');

      } catch (error) {
        console.error('âŒ å›¾è¡¨æ›´æ–°å¤±è´¥:', error);

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        if (chart && chart.setOption) {
          chart.setOption({
            backgroundColor: '#fff',
            title: {
              text: 'å›¾è¡¨æ›´æ–°å¤±è´¥',
              subtext: error.message,
              left: 'center',
              top: 'middle',
              textStyle: {
                color: '#f56565',
                fontSize: 16
              }
            }
          });
        }
      } finally {
        // æ¸…é™¤æ›´æ–°çŠ¶æ€
        const deviceKey = String(device).replace(/\s+/g, '-');
        if (window.chartUpdateInProgress) {
          delete window.chartUpdateInProgress[deviceKey];
        }
      }
    }

    // æŸ¥æ‰¾é…ç½®å®¹å™¨
    function findConfigContainer(device) {
      const containers = document.querySelectorAll('.chart-config-container');
      for (let container of containers) {
        const parent = container.closest('.device-group');
        if (parent) {
          const deviceHeader = parent.querySelector('h2');
          if (deviceHeader && deviceHeader.textContent.includes(device)) {
            return container;
          }
        }
      }
      return null;
    }

    // ä»é…ç½®å®¹å™¨è·å–å›¾è¡¨é…ç½®
    function getChartConfigFromContainer(device, configContainer = null) {
      const deviceStr = String(device);

      if (!configContainer) {
        configContainer = findConfigContainer(deviceStr);
      }

      if (!configContainer) {
        console.log('æœªæ‰¾åˆ°é…ç½®å®¹å™¨ï¼Œè®¾å¤‡:', deviceStr);
        return { isValid: false };
      }

      const dim1 = configContainer.querySelector('#dim1-select').value;
      const dim1Value = configContainer.querySelector('#dim1-value').value;
      const dim2 = configContainer.querySelector('#dim2-select').value;
      const dim2Value = configContainer.querySelector('#dim2-value').value;
      const dim3Enable = configContainer.querySelector('#dim3-enable').checked;
      const dim3 = configContainer.querySelector('#dim3-select').value;
      const dim3Value = configContainer.querySelector('#dim3-value').value;
      const xAxis = configContainer.querySelector('#x-axis-select').value;

      // æ£€æŸ¥é…ç½®æ˜¯å¦å®Œæ•´
      const isValid = dim1 && dim1Value && dim2 && dim2Value && xAxis;
      console.log('é…ç½®éªŒè¯:', {
        dim1, dim1Value, dim2, dim2Value, xAxis, isValid
      });

      return {
        isValid,
        fixedDimensions: [
          { dimension: dim1, value: dim1Value },
          { dimension: dim2, value: dim2Value },
          ...(dim3Enable && dim3 && dim3Value ? [{ dimension: dim3, value: dim3Value }] : [])
        ],
        xAxis,
        device: deviceStr
      };
    }

    // ç”Ÿæˆå›¾è¡¨æ•°æ®
    function generateChartData(perfRows, config) {
      console.log('=== å¼€å§‹ç”Ÿæˆå›¾è¡¨æ•°æ® ===');
      console.log('åŸå§‹æ•°æ®é‡:', perfRows.length);
      console.log('é…ç½®:', config);

      // æ‰“å°å‰å‡ è¡Œæ•°æ®çœ‹çœ‹ç»“æ„
      if (perfRows.length > 0) {
        console.log('æ•°æ®ç¤ºä¾‹:', perfRows[0]);
      }

      // æ ¹æ®å›ºå®šç»´åº¦ç­›é€‰æ•°æ®
      let filteredData = perfRows.filter(row => {
        let allMatch = true;
        for (const fixedDim of config.fixedDimensions) {
          const rowValue = getRowValue(row, fixedDim.dimension);
          const isMatch = rowValue === fixedDim.value;
          console.log(`æ£€æŸ¥ç»´åº¦ ${fixedDim.dimension}: æœŸæœ›="${fixedDim.value}", å®é™…="${rowValue}", åŒ¹é…=${isMatch}`);
          if (!isMatch) {
            allMatch = false;
            break;
          }
        }
        return allMatch;
      });

      console.log('ç­›é€‰åæ•°æ®é‡:', filteredData.length);

      if (filteredData.length === 0) {
        console.error('âŒ ç­›é€‰åæ²¡æœ‰æ•°æ®ï¼è¯·æ£€æŸ¥ç­›é€‰æ¡ä»¶');
        return { xAxisValues: [], series: [], config };
      }

      // è·å–Xè½´æ•°æ®
      const xAxisValues = [...new Set(filteredData.map(row => getRowValue(row, config.xAxis)))];

      // å¯¹Xè½´æ•°æ®è¿›è¡Œæ’åº
      if (config.xAxis === 'concurrency') {
        xAxisValues.sort((a, b) => parseInt(a) - parseInt(b));
      } else if (config.xAxis === 'version') {
        xAxisValues.sort(compareVersionAsc);
      } else if (config.xAxis === 'token_combination') {
        // å¯¹è¾“å…¥/è¾“å‡ºè¿›è¡Œè‡ªå®šä¹‰æ’åºï¼šå…ˆæŒ‰è¾“å…¥æ•°å­—å¤§å°ï¼Œå†æŒ‰è¾“å‡ºæ•°å­—å¤§å°
        xAxisValues.sort((a, b) => {
          // è§£æ "è¾“å…¥/è¾“å‡º" æ ¼å¼ï¼Œä¾‹å¦‚ "512/1024"
          const parseTokens = (str) => {
            const parts = str.split('/');
            return {
              input: parseInt(parts[0]) || 0,
              output: parseInt(parts[1]) || 0
            };
          };

          const tokensA = parseTokens(a);
          const tokensB = parseTokens(b);

          // å…ˆæŒ‰è¾“å…¥æ•°å­—æ’åº
          if (tokensA.input !== tokensB.input) {
            return tokensA.input - tokensB.input;
          }

          // è¾“å…¥ç›¸ç­‰æ—¶ï¼ŒæŒ‰è¾“å‡ºæ•°å­—æ’åº
          return tokensA.output - tokensB.output;
        });
      } else {
        xAxisValues.sort();
      }

      console.log('Xè½´æ•°æ®:', xAxisValues);

      // è·å–å›¾ä¾‹ç»´åº¦ï¼ˆå‰©ä½™æœªä½¿ç”¨çš„ç»´åº¦ï¼‰
      const allDimensions = ['model', 'version', 'concurrency', 'token_combination'];
      const usedDimensions = [
        ...config.fixedDimensions.map(d => d.dimension),
        config.xAxis
      ];
      const legendDimensions = allDimensions.filter(dim => !usedDimensions.includes(dim));
      console.log('å›¾ä¾‹ç»´åº¦:', legendDimensions);

      // ç”Ÿæˆç³»åˆ—æ•°æ®
      const series = [];
      console.log('å¼€å§‹ç”Ÿæˆç³»åˆ—æ•°æ®ï¼Œå›¾ä¾‹ç»´åº¦æ•°é‡:', legendDimensions.length);

      if (legendDimensions.length === 0) {
        // æ²¡æœ‰å›¾ä¾‹ç»´åº¦ï¼Œåªæœ‰ä¸€æ¡çº¿
        const seriesData = xAxisValues.map(xValue => {
          const matchingRows = filteredData.filter(row =>
            getRowValue(row, config.xAxis) === xValue
          );

          if (matchingRows.length > 0) {
            const avgThroughput = matchingRows.reduce((sum, row) =>
              sum + (row.output_throughput || 0), 0) / matchingRows.length;
            return avgThroughput.toFixed(2);
          }
          return null;
        });

        series.push({
          name: 'ååé‡',
          data: seriesData
        });
      } else if (legendDimensions.length === 1) {
        // å•ä¸ªå›¾ä¾‹ç»´åº¦
        const legendDim = legendDimensions[0];
        const legendValues = [...new Set(filteredData.map(row => getRowValue(row, legendDim)))].sort();
        console.log('å›¾ä¾‹å€¼:', legendValues);

        legendValues.forEach(legendValue => {
          const seriesData = xAxisValues.map(xValue => {
            const matchingRows = filteredData.filter(row =>
              getRowValue(row, config.xAxis) === xValue &&
              getRowValue(row, legendDim) === legendValue
            );

            if (matchingRows.length > 0) {
              const avgThroughput = matchingRows.reduce((sum, row) =>
                sum + (row.output_throughput || 0), 0) / matchingRows.length;
              return avgThroughput.toFixed(2);
            }
            return null;
          });

          series.push({
            name: legendValue,
            data: seriesData
          });
        });
      } else {
        // å¤šä¸ªå›¾ä¾‹ç»´åº¦ï¼Œç®€åŒ–å¤„ç†
        console.log('å¤šä¸ªå›¾ä¾‹ç»´åº¦ï¼Œä½¿ç”¨ç®€åŒ–å¤„ç†');
        const seriesData = xAxisValues.map(xValue => {
          const matchingRows = filteredData.filter(row =>
            getRowValue(row, config.xAxis) === xValue
          );

          if (matchingRows.length > 0) {
            const avgThroughput = matchingRows.reduce((sum, row) =>
              sum + (row.output_throughput || 0), 0) / matchingRows.length;
            return avgThroughput.toFixed(2);
          }
          return null;
        });

        series.push({
          name: 'å¹³å‡ååé‡',
          data: seriesData
        });
      }

      console.log('ç”Ÿæˆçš„ç³»åˆ—æ•°æ®:', series);

      return {
        xAxisValues,
        series,
        config
      };
    }

    // è·å–è¡Œçš„ç»´åº¦å€¼
    function getRowValue(row, dimension) {
      let value;
      switch (dimension) {
        case 'model':
          const remark = row.entry?.base_info?.remark?.trim() || '';
          value = remark ? `${row.model} (${remark})` : row.model;
          break;
        case 'version':
          value = row.version;
          break;
        case 'concurrency':
          value = row.concurrency.toString();
          break;
        case 'token_combination':
          const expectedIn = row.expected_input || row.input_tokens;
          const expectedOut = row.expected_output || row.output_tokens;
          value = `${expectedIn}/${expectedOut}`;
          break;
        default:
          value = '';
      }
      return value;
    }

    // è·å–ç»´åº¦æ ‡ç­¾
    function getDimensionLabel(dimension) {
      const labels = {
        'model': 'æ¨¡å‹',
        'version': 'ç‰ˆæœ¬',
        'concurrency': 'å¹¶å‘æ•°',
        'token_combination': 'è¾“å…¥/è¾“å‡º'
      };
      return labels[dimension] || dimension;
    }

    // è·å–å”¯ä¸€ç»„åˆ
    function getUniqueCombinations(data, dimensions) {
      const combinations = new Map();

      data.forEach(row => {
        const combination = {};
        dimensions.forEach(dim => {
          combination[dim] = getRowValue(row, dim);
        });

        const key = JSON.stringify(combination);
        combinations.set(key, combination);
      });

      return Array.from(combinations.values());
    }

    // åˆå§‹åŒ–ç²¾åº¦å›¾è¡¨
    function initAccuracyChart(canvas, accRows, device, accFilterContainer) {
      console.log('åˆå§‹åŒ–ç²¾åº¦å›¾è¡¨ï¼Œè®¾å¤‡:', device, 'ç²¾åº¦æ•°æ®é‡:', accRows.length);

      // æ›¿æ¢canvasä¸ºdivå®¹å™¨
      const chartDiv = document.createElement('div');
      chartDiv.className = 'chart-container';
      chartDiv.style.cssText = 'height: 500px; width: 1000px; min-width: 1000px;';
      canvas.parentNode.replaceChild(chartDiv, canvas);

      // åˆå§‹åŒ–EChartså®ä¾‹
      const chart = echarts.init(chartDiv);

      // ä¿å­˜å›¾è¡¨å®ä¾‹
      const deviceKey = String(device).replace(/\s+/g, '-');
      if (!window.chartInstances) window.chartInstances = {};
      if (!window.chartInstances[deviceKey]) window.chartInstances[deviceKey] = {};
      window.chartInstances[deviceKey].accuracyChart = chart;

      // ä¿å­˜å½“å‰è®¾å¤‡çš„ç²¾åº¦æ•°æ®
      if (!window.deviceAccRows) window.deviceAccRows = {};
      window.deviceAccRows[deviceKey] = accRows;

      // æ¸²æŸ“ç²¾åº¦å›¾è¡¨
      renderAccuracyChart(chart, accRows);

      // è®¾ç½®ç²¾åº¦ç­›é€‰å™¨äº‹ä»¶ç›‘å¬
      if (accFilterContainer) {
        setTimeout(() => {
          setupAccuracyFilterListeners(chart, accRows, device, accFilterContainer);
        }, 100);
      }
    }

    // æ¸²æŸ“ç²¾åº¦å›¾è¡¨
    function renderAccuracyChart(chart, accRows) {
      console.log('=== æ¸²æŸ“ç²¾åº¦å›¾è¡¨ ===');
      console.log('ç²¾åº¦æ•°æ®é‡:', accRows.length);

      if (!accRows || accRows.length === 0) {
        chart.setOption({
          backgroundColor: '#fff',
          title: {
            text: 'æš‚æ— ç²¾åº¦æµ‹è¯•æ•°æ®',
            left: 'center',
            top: 'middle',
            textStyle: {
              color: '#999',
              fontSize: 16
            }
          }
        });
        return;
      }

      // æ‰“å°ç²¾åº¦æ•°æ®ç»“æ„
      console.log('ç²¾åº¦æ•°æ®ç¤ºä¾‹:', accRows[0]);

      // æŒ‰æ¨¡å‹åˆ†ç»„æ•°æ®
      const seriesData = new Map();

      accRows.forEach((row, index) => {
        console.log(`å¤„ç†ç²¾åº¦æ•°æ® ${index}:`, {
          model: row.model,
          version: row.version,
          score: row.score,
          remark: row.entry?.base_info?.remark
        });

        const remark = row.entry?.base_info?.remark?.trim() || '';
        const modelKey = remark ? `${row.model} (${remark})` : row.model;

        if (!seriesData.has(modelKey)) {
          seriesData.set(modelKey, new Map());
        }

        // ç¡®ä¿scoreæ˜¯æ•°å­—ç±»å‹ï¼Œå¹¶è½¬æ¢ä¸ºç™¾åˆ†æ¯”
        let score = row.score;
        if (typeof score === 'string') {
          score = parseFloat(score);
        }

        // å¦‚æœåˆ†æ•°å°äºç­‰äº1ï¼Œè®¤ä¸ºæ˜¯å°æ•°å½¢å¼ï¼Œè½¬æ¢ä¸ºç™¾åˆ†æ¯”
        const scorePercent = score <= 1 ? score * 100 : score;

        // ä½¿ç”¨Mapæ¥é¿å…ç‰ˆæœ¬é‡å¤
        seriesData.get(modelKey).set(row.version, scorePercent);
      });

      console.log('åˆ†ç»„åçš„ç²¾åº¦æ•°æ®:', seriesData);

      // è·å–æ‰€æœ‰ç‰ˆæœ¬å¹¶æ’åº
      const allVersions = [...new Set(accRows.map(r => r.version))].sort(compareVersionAsc);
      console.log('æ‰€æœ‰ç‰ˆæœ¬:', allVersions);

      // ç”Ÿæˆç³»åˆ—æ•°æ®
      const series = [];
      const colors = ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4'];
      let colorIndex = 0;

      seriesData.forEach((versionScoreMap, modelKey) => {
        console.log(`ç”Ÿæˆç³»åˆ—æ•°æ® - æ¨¡å‹: ${modelKey}`);

        // ä¸ºæ¯ä¸ªç‰ˆæœ¬å¡«å……æ•°æ®
        const seriesValues = allVersions.map(version => {
          const score = versionScoreMap.get(version);
          console.log(`  ç‰ˆæœ¬ ${version}: ${score}`);
          return score !== undefined ? score : null;
        });

        console.log(`æ¨¡å‹ ${modelKey} çš„æ•°æ®:`, seriesValues);

        series.push({
          name: modelKey,
          type: 'line',
          data: seriesValues,
          connectNulls: false,
          symbol: 'circle',
          symbolSize: 8,
          lineStyle: {
            width: 3
          },
          itemStyle: {
            color: colors[colorIndex % colors.length]
          },
          emphasis: {
            focus: 'series'
          }
        });
        colorIndex++;
      });

      console.log('æœ€ç»ˆç³»åˆ—æ•°æ®:', series);

      const option = {
        backgroundColor: '#fff',
        title: {
          text: 'ç²¾åº¦æµ‹è¯•å‡†ç¡®ç‡',
          left: 'center',
          top: 15,
          textStyle: {
            fontSize: 18,
            fontWeight: 'bold',
            color: '#333'
          }
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(255,255,255,0.95)',
          borderColor: '#ddd',
          borderWidth: 1,
          padding: [10, 15],
          textStyle: {
            fontSize: 13
          },
          formatter: function(params) {
            let result = `<div style="font-weight:bold;margin-bottom:8px;color:#333;">ç‰ˆæœ¬: ${params[0].axisValue}</div>`;
            params.forEach(param => {
              if (param.value !== null && param.value !== undefined) {
                result += `<div style="margin:4px 0;display:flex;align-items:center;">
                  <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${param.color};margin-right:8px;"></span>
                  <span>${param.seriesName}: <strong>${Number(param.value).toFixed(1)}%</strong></span>
                </div>`;
              }
            });
            return result;
          }
        },
        legend: {
          data: series.map(s => s.name),
          top: 50,
          type: 'scroll',
          textStyle: {
            fontSize: 13
          },
          itemGap: 20
        },
        grid: {
          left: '8%',
          right: '5%',
          bottom: '12%',
          top: '15%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          data: allVersions,
          name: 'ç‰ˆæœ¬',
          nameLocation: 'middle',
          nameGap: 25,
          nameTextStyle: {
            fontSize: 14,
            fontWeight: 'bold'
          },
          axisLabel: {
            interval: 0,
            rotate: allVersions.length > 6 ? 30 : 0,
            fontSize: 12
          },
          axisLine: {
            lineStyle: {
              color: '#666'
            }
          }
        },
        yAxis: {
          type: 'value',
          name: 'å‡†ç¡®ç‡ (%)',
          min: 0,
          max: 100,
          axisLabel: {
            formatter: '{value}%'
          }
        },
        series: series
      };

      chart.setOption(option);
    }

    // è®¾ç½®ç²¾åº¦ç­›é€‰å™¨äº‹ä»¶ç›‘å¬
    function setupAccuracyFilterListeners(chart, accRows, device, accFilterContainer) {
      console.log('è®¾ç½®ç²¾åº¦ç­›é€‰å™¨ç›‘å¬ï¼Œè®¾å¤‡:', device);
      const filterSelects = accFilterContainer.querySelectorAll('select[data-filter]');
      filterSelects.forEach(select => {
        select.addEventListener('change', () => {
          console.log('ç²¾åº¦ç­›é€‰å™¨å˜åŒ–ï¼Œè®¾å¤‡:', device);
          // ä½¿ç”¨å½“å‰è®¾å¤‡çš„ç²¾åº¦æ•°æ®
          const deviceKey = String(device).replace(/\s+/g, '-');
          const deviceAccRows = window.deviceAccRows?.[deviceKey] || accRows;
          const filteredData = getFilteredAccuracyData(deviceAccRows, accFilterContainer);
          renderAccuracyChart(chart, filteredData);
        });
      });
    }

    // è·å–ç­›é€‰åçš„ç²¾åº¦æ•°æ®
    function getFilteredAccuracyData(accRows, accFilterContainer) {
      const filterSelects = accFilterContainer.querySelectorAll('select[data-filter]');

      // æ”¶é›†ç­›é€‰æ¡ä»¶
      const filters = {};
      filterSelects.forEach(select => {
        const filterType = select.dataset.filter;
        const selectedValues = Array.from(select.selectedOptions)
          .map(option => option.value)
          .filter(value => value !== '__ALL__');
        if (selectedValues.length > 0) {
          filters[filterType] = selectedValues;
        }
      });

      return accRows.filter(row => {
        for (const [filterType, selectedValues] of Object.entries(filters)) {
          let match = false;

          switch (filterType) {
            case 'model':
              const rowRemark = row.entry?.base_info?.remark?.trim() || '';
              const rowModelKey = rowRemark ? `${row.model}_${rowRemark}` : row.model;
              match = selectedValues.includes(rowModelKey);
              break;
            case 'version':
              match = selectedValues.includes(row.version);
              break;
          }

          if (!match) return false;
        }
        return true;
      });
    }

    // è®¾ç½®é…ç½®åŒ–å›¾è¡¨çš„äº‹ä»¶ç›‘å¬å™¨
    function setupConfigurableChartListeners(chart, perfRows, device, chartConfigContainer) {
      console.log('ğŸ§ è®¾ç½®å›¾è¡¨äº‹ä»¶ç›‘å¬å™¨');

      // åªä¸ºå›¾è¡¨æ›´æ–°ç›¸å…³çš„å…ƒç´ æ·»åŠ ç›‘å¬å™¨ï¼Œä¸ç ´ååŸæœ‰çš„ç»´åº¦é€‰æ‹©åŠŸèƒ½
      if (chartConfigContainer && !chartConfigContainer.dataset.chartListenersSet) {
        // åªç›‘å¬å€¼é€‰æ‹©å™¨çš„å˜åŒ–ï¼Œä¸ç›‘å¬ç»´åº¦é€‰æ‹©å™¨
        const valueSelects = chartConfigContainer.querySelectorAll('#dim1-value, #dim2-value, #dim3-value, #x-axis-select');
        console.log('æ‰¾åˆ°å€¼é€‰æ‹©å™¨æ•°é‡:', valueSelects.length);

        valueSelects.forEach(element => {
          element.addEventListener('change', () => {
            console.log('å€¼é€‰æ‹©å™¨å˜åŒ–ï¼Œè§¦å‘å›¾è¡¨æ›´æ–°:', element.id);

            // è·å–æœ€æ–°çš„å›¾è¡¨å®ä¾‹
            const deviceKey = String(device).replace(/\s+/g, '-');
            const currentChart = window.chartInstances?.[deviceKey]?.configurableChart;
            const currentPerfRows = window.devicePerfRows?.[deviceKey] || perfRows;

            if (currentChart && currentPerfRows) {
              updateConfigurableChart(currentChart, currentPerfRows, device, chartConfigContainer);
            } else {
              console.error('âŒ å›¾è¡¨å®ä¾‹æˆ–æ•°æ®ä¸¢å¤±:', { currentChart: !!currentChart, currentPerfRows: currentPerfRows?.length });
            }
          });
        });

        // æ ‡è®°ç›‘å¬å™¨å·²è®¾ç½®
        chartConfigContainer.dataset.chartListenersSet = 'true';
        console.log('âœ… å›¾è¡¨æ›´æ–°ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
      } else if (chartConfigContainer) {
        console.log('âš ï¸ å›¾è¡¨æ›´æ–°ç›‘å¬å™¨å·²å­˜åœ¨ï¼Œè·³è¿‡è®¾ç½®');
      } else {
        console.log('âŒ æœªæ‰¾åˆ°å›¾è¡¨é…ç½®å®¹å™¨');
      }

      console.log('âœ… å›¾è¡¨äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
      return Promise.resolve();
    }

    // è·å–æŒ‡å®šè®¾å¤‡çš„ç­›é€‰åæ•°æ®
    function getFilteredDataForDevice(device) {
      // è¿™é‡Œéœ€è¦æ ¹æ®è®¾å¤‡æ‰¾åˆ°å¯¹åº”çš„ç­›é€‰å™¨å’Œæ•°æ®
      // æš‚æ—¶è¿”å›åŸå§‹æ•°æ®ï¼Œåç»­å¯ä»¥å®Œå–„
      return window.currentPerfRows || [];
    }

    // ç”Ÿæˆå›¾è¡¨é€‰é¡¹
    function generateChartOption(chartData, config) {
      const fixedInfo = config.fixedDimensions.map(fd =>
        `${getDimensionLabel(fd.dimension)}: ${fd.value}`
      ).join('ã€');

      return {
        backgroundColor: '#fff',
        title: {
          text: 'æ€§èƒ½å¯¹æ¯”å›¾è¡¨',
          subtext: `å›ºå®šæ¡ä»¶: ${fixedInfo}`,
          left: 'center',
          top: 20,
          textStyle: {
            fontSize: 16,
            fontWeight: 'bold',
            color: '#333'
          },
          subtextStyle: {
            fontSize: 12,
            color: '#666'
          }
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(255,255,255,0.98)',
          borderColor: '#e2e8f0',
          borderWidth: 1,
          padding: [8, 12],
          formatter: function(params) {
            let result = `<div style="font-weight:bold;margin-bottom:6px;">${getDimensionLabel(config.xAxis)}: ${params[0].axisValue}</div>`;
            params.forEach(param => {
              if (param.value !== null && param.value !== undefined) {
                // ç¡®ä¿valueæ˜¯æ•°å­—ç±»å‹
                const value = typeof param.value === 'number' ? param.value : parseFloat(param.value);
                const displayValue = isNaN(value) ? param.value : value.toFixed(2);

                result += `<div style="margin:2px 0;">
                  <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${param.color};margin-right:6px;"></span>
                  ${param.seriesName}: <strong>${displayValue} tokens/s</strong>
                </div>`;
              }
            });
            return result;
          }
        },
        legend: {
          data: chartData.series.map(s => s.name),
          top: 55,
          type: 'scroll',
          textStyle: {
            fontSize: 12
          }
        },
        grid: {
          left: '8%',
          right: '5%',
          bottom: '12%',
          top: '18%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          data: chartData.xAxisValues,
          name: getDimensionLabel(config.xAxis),
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: {
            fontSize: 13
          },
          axisLabel: {
            rotate: 0,
            fontSize: 11,
            interval: 0
          }
        },
        yAxis: {
          type: 'value',
          name: 'ååé‡ (tokens/s)'
        },
        series: chartData.series.map(seriesData => ({
          name: seriesData.name,
          type: 'line',
          data: seriesData.data,
          connectNulls: false,
          symbol: 'circle',
          symbolSize: 8,
          lineStyle: {
            width: 3
          },
          emphasis: {
            focus: 'series'
          }
        }))
      };
    }

    function drawBarChartsPure(perfRows, canvas1, canvas2, accuracyCanvas, data, device, chartConfigContainer, filterContainer, tableContainer, accRows, heatmapDiv, accFilterContainer) {
      try {
        // æ·»åŠ å¿…è¦çš„å˜é‡å®šä¹‰
        const models = Array.from(new Set(perfRows.map(r => r.model)));
        const concurrencies = Array.from(new Set(perfRows.map(r => r.concurrency))).sort((a, b) => a - b);
        const versions = Array.from(new Set(perfRows.map(r => r.version))).sort(compareVersionAsc);

        // åˆ›å»ºè®¾å¤‡ç‰¹å®šçš„å›¾è¡¨å®ä¾‹å­˜å‚¨
        const deviceKey = device.replace(/\s+/g, '-');
        if (!window.chartInstances) {
          window.chartInstances = {};
        }
        
        // ä¿®æ”¹å®¹å™¨åˆ›å»ºå’Œæ›¿æ¢éƒ¨åˆ†
        const ttft3dDiv = document.createElement('div');
        ttft3dDiv.className = 'chart-wrap';
        ttft3dDiv.style.cssText = 'height: 500px; width: 100%;';
        ttft3dDiv.innerHTML = '<div class="chart-title">TTFT 3Då±•ç¤º</div>';
        
        const output3dDiv = document.createElement('div');
        output3dDiv.className = 'chart-wrap';
        output3dDiv.style.cssText = 'height: 500px; width: 100%;';
        output3dDiv.innerHTML = '<div class="chart-title">ååé‡ 3Då±•ç¤º</div>';

        // æ›¿æ¢åŸæœ‰canvas
        canvas1.parentNode.replaceWith(ttft3dDiv);
        canvas2.parentNode.replaceWith(output3dDiv);

        // åˆ›å»ºç²¾åº¦å›¾è¡¨å®¹å™¨
        const accuracy2dDiv = document.createElement('div');
        accuracy2dDiv.className = 'chart-container';
        accuracy2dDiv.style.cssText = 'height: 400px; width: 100%;';

        // å°†ç²¾åº¦å›¾è¡¨å®¹å™¨æ·»åŠ åˆ°ç²¾åº¦å›¾è¡¨åŒºåŸŸ
        const accDiv = accuracyCanvas.parentNode;
        accDiv.appendChild(accuracy2dDiv);

        // åˆ›å»ºçƒ­åŠ›å›¾å®¹å™¨
        const heatmap2dDiv = document.createElement('div');
        heatmap2dDiv.className = 'chart-container';
        heatmap2dDiv.style.cssText = 'height: 500px; width: 100%;';
        heatmapDiv.appendChild(heatmap2dDiv);

        // ç”Ÿæˆ3Dæ•°æ®å‡½æ•°å®šä¹‰
        function generate3DData(type = 'ttft') {
          const data = [];
          models.forEach((model, modelIndex) => {
            concurrencies.forEach((concurrency, j) => {
              versions.forEach((version, k) => {
                const row = perfRows.find(r => 
                  r.model === model && 
                  r.concurrency === concurrency && 
                  r.version === version
                );
                if (row) {
                  const value = type === 'ttft' ? row.avg_ttft : row.output_throughput;
                  data.push([
                    j,                    // X: å¹¶å‘æ•°ç´¢å¼•
                    k,                    // Y: ç‰ˆæœ¬ç´¢å¼•
                    value,                // Z: æ€§èƒ½å€¼
                    model,                // æ¨¡å‹å
                    concurrency,          // åŸå§‹å¹¶å‘æ•°
                    version,              // åŸå§‹ç‰ˆæœ¬å·
                    COLOR_PALETTE[modelIndex % COLOR_PALETTE.length]  // é¢œè‰²
                  ]);
                }
              });
            });
          });
          return data;
        }

        // ç²¾åº¦å›¾è¡¨é…ç½®å‡½æ•°
        function getAccuracyChartOption() {
          if (!accRows || accRows.length === 0) {
            return {
              backgroundColor: '#fff',
              title: {
                text: 'æš‚æ— ç²¾åº¦æµ‹è¯•æ•°æ®',
                left: 'center',
                top: 'middle',
                textStyle: {
                  color: '#999',
                  fontSize: 16
                }
              }
            };
          }

          // è·å–æ‰€æœ‰ç‰ˆæœ¬å¹¶æ’åº
          const versions = [...new Set(accRows.map(row => row.version))].sort(compareVersionAsc);

          // æŒ‰æ¨¡å‹åˆ†ç»„ï¼Œæ¯ä¸ªæ¨¡å‹ä¸€ä¸ªç³»åˆ—
          const modelGroups = new Map();
          accRows.forEach(row => {
            // ä»entryä¸­è·å–remarkä¿¡æ¯
            const model = row.model;
            const remark = row.entry?.base_info?.remark?.trim() || '';
            const modelDisplayName = remark ? `${model} (${remark})` : model;

            if (!modelGroups.has(modelDisplayName)) {
              modelGroups.set(modelDisplayName, new Map());
            }
            modelGroups.get(modelDisplayName).set(row.version, row.score * 100);
          });

          // åˆ›å»ºç³»åˆ—æ•°æ®
          const series = Array.from(modelGroups.entries()).map(([modelName, versionScores], index) => {
            const data = versions.map(version => versionScores.get(version) || null);

            return {
              name: modelName,
              type: 'line',
              data: data,
              lineStyle: {
                color: COLOR_PALETTE[index % COLOR_PALETTE.length],
                width: 3
              },
              itemStyle: {
                color: COLOR_PALETTE[index % COLOR_PALETTE.length],
                borderWidth: 2,
                borderColor: '#fff'
              },
              symbol: 'circle',
              symbolSize: 8,
              label: {
                show: true,
                position: 'top',
                formatter: function(params) {
                  return params.value ? `${params.value.toFixed(1)}%` : '';
                },
                textStyle: {
                  fontSize: 11,
                  fontWeight: 'bold'
                }
              },
              emphasis: {
                focus: 'series',
                lineStyle: {
                  width: 4
                },
                itemStyle: {
                  borderWidth: 3,
                  shadowBlur: 10,
                  shadowColor: 'rgba(0,0,0,0.3)'
                }
              }
            };
          });

          return {
            backgroundColor: '#fff',
            tooltip: {
              trigger: 'axis',
              backgroundColor: 'rgba(255,255,255,0.98)',
              borderColor: '#e2e8f0',
              borderWidth: 1,
              padding: [12, 16],
              textStyle: {
                color: '#334155',
                fontSize: 12
              },
              formatter: function(params) {
                let result = `<div style="font-weight:bold;margin-bottom:6px;">ç‰ˆæœ¬: ${params[0].axisValue}</div>`;
                params.forEach(param => {
                  if (param.value !== null) {
                    const color = param.color;
                    result += `<div style="margin:2px 0;">
                      <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};margin-right:6px;"></span>
                      ${param.seriesName}: <strong>${param.value.toFixed(2)}%</strong>
                    </div>`;
                  }
                });
                return result;
              }
            },
            legend: {
              data: series.map(s => s.name),
              top: 15,
              type: 'scroll',
              textStyle: {
                fontSize: 12
              }
            },
            grid: {
              left: '3%',
              right: '4%',
              bottom: '8%',
              top: '15%',
              containLabel: true
            },
            xAxis: {
              type: 'category',
              data: versions,
              name: 'ç‰ˆæœ¬',
              nameLocation: 'middle',
              nameGap: 25,
              nameTextStyle: {
                fontSize: 13,
                fontWeight: 'bold',
                color: '#333'
              },
              axisLabel: {
                rotate: versions.length > 5 ? 45 : 0,
                interval: 0,
                fontSize: 12,
                fontWeight: 'normal',
                color: '#666'
              },
              axisLine: {
                show: true,
                lineStyle: {
                  color: '#333',
                  width: 1
                }
              },
              axisTick: {
                show: true,
                lineStyle: {
                  color: '#333'
                }
              }
            },
            yAxis: {
              type: 'value',
              name: 'å‡†ç¡®ç‡ (%)',
              nameLocation: 'middle',
              nameGap: 40,
              nameTextStyle: {
                fontSize: 13,
                fontWeight: 'bold',
                color: '#333'
              },
              min: function(value) {
                return Math.max(0, value.min - 5); // åŠ¨æ€æœ€å°å€¼ï¼Œä½†ä¸ä½äº0
              },
              max: 100,
              axisLabel: {
                formatter: '{value}%',
                fontSize: 12,
                fontWeight: 'normal',
                color: '#666'
              },
              axisLine: {
                show: true,
                lineStyle: {
                  color: '#333',
                  width: 1
                }
              },
              axisTick: {
                show: true,
                lineStyle: {
                  color: '#333'
                }
              },
              splitLine: {
                show: true,
                lineStyle: {
                  color: '#e8e8e8',
                  width: 1,
                  type: 'dashed'
                }
              }
            },
            series: series
          };
        }

        // çƒ­åŠ›å›¾é…ç½®å‡½æ•°
        function getHeatmapChartOption() {
          if (!perfRows || perfRows.length === 0) {
            return {
              backgroundColor: '#fff',
              title: {
                text: 'æš‚æ— æ€§èƒ½æµ‹è¯•æ•°æ®',
                left: 'center',
                top: 'middle',
                textStyle: {
                  color: '#999',
                  fontSize: 16
                }
              }
            };
          }

          // è·å–æ‰€æœ‰å”¯ä¸€çš„æ¨¡å‹ç»„åˆ
          const modelCombinations = [...new Set(perfRows.map(r => {
            const remark = r.entry?.base_info?.remark?.trim() || '';
            return remark ? `${r.model} (${remark})` : r.model;
          }))].sort();

          // è·å–æ‰€æœ‰ç‰ˆæœ¬å’Œå¹¶å‘æ•°
          const versions = [...new Set(perfRows.map(r => r.version))].sort(compareVersionAsc);
          const concurrencies = [...new Set(perfRows.map(r => r.concurrency))].sort((a, b) => a - b);

          // ç”Ÿæˆçƒ­åŠ›å›¾æ•°æ® - ç‰ˆæœ¬ x å¹¶å‘æ•°
          const heatmapData = [];
          const maxValue = Math.max(...perfRows.map(r => r.output_throughput || 0));

          versions.forEach((version, vIndex) => {
            concurrencies.forEach((concurrency, cIndex) => {
              // æ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„æ•°æ®è¡Œï¼Œè®¡ç®—å¹³å‡å€¼
              const matchingRows = perfRows.filter(r =>
                r.version === version && r.concurrency === concurrency
              );

              if (matchingRows.length > 0) {
                const avgThroughput = matchingRows.reduce((sum, r) =>
                  sum + (r.output_throughput || 0), 0) / matchingRows.length;

                heatmapData.push([cIndex, vIndex, avgThroughput]);
              }
            });
          });

          return {
            backgroundColor: '#fff',
            title: {
              text: 'æ€§èƒ½çƒ­åŠ›å›¾ - ååé‡ (tokens/s)',
              left: 'center',
              top: 10,
              textStyle: {
                fontSize: 16,
                fontWeight: 'bold'
              }
            },
            tooltip: {
              position: 'top',
              backgroundColor: 'rgba(255,255,255,0.98)',
              borderColor: '#e2e8f0',
              borderWidth: 1,
              padding: [8, 12],
              formatter: function(params) {
                const [cIndex, vIndex, value] = params.data;
                const concurrency = concurrencies[cIndex];
                const version = versions[vIndex];
                return `
                  <div style="font-size:12px;">
                    <div><strong>ç‰ˆæœ¬:</strong> ${version}</div>
                    <div><strong>å¹¶å‘æ•°:</strong> ${concurrency}</div>
                    <div><strong>å¹³å‡ååé‡:</strong> ${value.toFixed(2)} tokens/s</div>
                  </div>
                `;
              }
            },
            grid: {
              height: '60%',
              top: '15%',
              left: '10%',
              right: '10%'
            },
            xAxis: {
              type: 'category',
              data: concurrencies,
              name: 'å¹¶å‘æ•°',
              nameLocation: 'middle',
              nameGap: 30,
              splitArea: {
                show: true
              }
            },
            yAxis: {
              type: 'category',
              data: versions,
              name: 'ç‰ˆæœ¬',
              nameLocation: 'middle',
              nameGap: 50,
              splitArea: {
                show: true
              }
            },
            visualMap: {
              min: 0,
              max: maxValue,
              calculable: true,
              orient: 'horizontal',
              left: 'center',
              bottom: '5%',
              inRange: {
                color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
              }
            },
            series: [{
              name: 'ååé‡',
              type: 'heatmap',
              data: heatmapData,
              label: {
                show: true,
                formatter: function(params) {
                  return params.data[2].toFixed(0);
                },
                fontSize: 10
              },
              emphasis: {
                itemStyle: {
                  shadowBlur: 10,
                  shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
              }
            }]
          };
        }

        // å›¾è¡¨é…ç½®å‡½æ•°å®šä¹‰

        function get3DChartOption(type) {
          const data = generate3DData(type);
          
          return {
            backgroundColor: '#fff',
            tooltip: {
              backgroundColor: 'rgba(255,255,255,0.98)',
              borderColor: '#e2e8f0',
              borderWidth: 1,
              padding: [2, 4],  // è¿›ä¸€æ­¥å‡å°å†…è¾¹è·
              textStyle: {
                color: '#334155',
                fontSize: 10,
                lineHeight: 12  // æ›´ç´§å‡‘çš„è¡Œé«˜
              },
              formatter: function(params) {
                if (!params || !params.data) {
                  return '<div style="font-size:10px;line-height:12px;margin:0;padding:0;">æ•°æ®ä¸å®Œæ•´</div>';
                }

                try {
                  // ä»æ•°æ®æ•°ç»„ä¸­è·å–å€¼
                  const [_, __, rawValue, model, concurrency, version] = params.data;

                  // æ ¼å¼åŒ–æ˜¾ç¤ºçš„å€¼
                  const value = type === 'ttft'
                    ? `${Number(rawValue).toFixed(2)} ms`
                    : `${Number(rawValue).toFixed(2)} tokens/s`;

                  // ä½¿ç”¨å•è¡Œç´§å‡‘å¸ƒå±€ï¼Œç”¨ | åˆ†éš”
                  return `<div style="font-size:10px;line-height:12px;margin:0;padding:0;white-space:nowrap;">
<span style="color:#64748b;">æ¨¡å‹:</span><span style="color:#1e40af;font-weight:600;">${model}</span> |
<span style="color:#64748b;">å¹¶å‘:</span><span style="color:#1e40af;font-weight:600;">${concurrency}</span><br>
<span style="color:#64748b;">ç‰ˆæœ¬:</span><span style="color:#1e40af;font-weight:600;">${version}</span> |
<span style="color:#64748b;">${type === 'ttft' ? 'TTFT' : 'ååé‡'}:</span><span style="color:#1e40af;font-weight:600;">${value}</span>
</div>`;
                } catch (error) {
                  console.error('Tooltip æ ¼å¼åŒ–é”™è¯¯:', error);
                  return '<div style="font-size:10px;line-height:12px;margin:0;padding:0;">æ•°æ®æ ¼å¼é”™è¯¯</div>';
                }
              },
              extraCssText: 'max-width:220px; white-space:normal; word-wrap:break-word; line-height:12px; height:auto;'
            },
            visualMap: {
              max: type === 'ttft' ? 2000 : 50,
              inRange: {
                color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8']
              }
            },
            xAxis3D: {
              type: 'category',
              name: 'å¹¶å‘æ•°',
              data: concurrencies,
              nameGap: 25,
              axisLine: {
                lineStyle: {
                  width: 2
                }
              },
              axisLabel: {
                margin: 8,
                interval: 0  // æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾
              }
            },
            yAxis3D: {
              type: 'category',
              name: 'ç‰ˆæœ¬',
              data: versions,
              nameGap: 25,
              axisLine: {
                lineStyle: {
                  width: 2
                }
              },
              axisLabel: {
                margin: 8,
                interval: 0  // æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾
              }
            },
            zAxis3D: {
              type: 'value',
              name: type === 'ttft' ? 'TTFT (ms)' : 'ååé‡ (tokens/s)',
              nameGap: 25,
              axisLine: {
                lineStyle: {
                  width: 2
                }
              }
            },
            grid3D: {
              boxWidth: 180,    // å‡å°ç›’å­å®½åº¦
              boxHeight: 100,   // å‡å°ç›’å­é«˜åº¦
              boxDepth: 100,    // å‡å°ç›’å­æ·±åº¦
              top: 10,          // å‡å°é¡¶éƒ¨é—´è·
              bottom: 10,       // å‡å°åº•éƒ¨é—´è·
              left: 10,         // å‡å°å·¦ä¾§é—´è·
              right: 10,        // å‡å°å³ä¾§é—´è·
              viewControl: {
                distance: 200,   // å‡å°è§†è·
                alpha: 25,      // è°ƒæ•´æ°´å¹³æ—‹è½¬è§’åº¦
                beta: 35,       // è°ƒæ•´å‚ç›´æ—‹è½¬è§’åº¦
                rotateSensitivity: 1.5,
                zoomSensitivity: 1.5,
                panSensitivity: 1.5,
                autoRotate: true,
                autoRotateSpeed: 8
              }
            },
            series: [{
              type: 'bar3D',
              data: data,
              shading: 'realistic',
              itemStyle: {
                opacity: 0.8,
                borderWidth: 0.5,  // å‡å°è¾¹æ¡†å®½åº¦
                borderColor: '#fff'
              },
              barSize: 4,         // å‡å°æŸ±å­å¤§å°
              minHeight: 1,       // å‡å°æœ€å°é«˜åº¦
              label: {
                show: false
              }
            }]
          };
        }

        // åˆå§‹åŒ–å›¾è¡¨å‡½æ•°
        function initCharts() {
          if (!ttft3dDiv.isConnected || !output3dDiv.isConnected || !accuracy2dDiv.isConnected || !heatmap2dDiv.isConnected) {
            console.error('å›¾è¡¨å®¹å™¨æœªæ·»åŠ åˆ°DOM');
            return;
          }

          try {
            console.log('å¼€å§‹åˆå§‹åŒ–å›¾è¡¨');

            // ç¡®ä¿å®¹å™¨å°ºå¯¸
            ttft3dDiv.style.height = '500px';
            output3dDiv.style.height = '500px';
            accuracy2dDiv.style.height = '400px';
            heatmap2dDiv.style.height = '500px';

            // åˆå§‹åŒ– ECharts å®ä¾‹
            const ttftChart = echarts.init(ttft3dDiv, null, {
              renderer: 'canvas',
              devicePixelRatio: window.devicePixelRatio || 1
            });
            const outputChart = echarts.init(output3dDiv, null, {
              renderer: 'canvas',
              devicePixelRatio: window.devicePixelRatio || 1
            });
            const accuracyChart = echarts.init(accuracy2dDiv, null, {
              renderer: 'canvas',
              devicePixelRatio: window.devicePixelRatio || 1
            });
            const heatmapChart = echarts.init(heatmap2dDiv, null, {
              renderer: 'canvas',
              devicePixelRatio: window.devicePixelRatio || 1
            });

            console.log('å›¾è¡¨å®ä¾‹åˆ›å»ºå®Œæˆ');

            // é…ç½®å’Œæ¸²æŸ“å›¾è¡¨
            const ttftOption = get3DChartOption('ttft');
            const outputOption = get3DChartOption('output');
            const accuracyOption = getAccuracyChartOption();
            const heatmapOption = getHeatmapChartOption();

            console.log('å›¾è¡¨é…ç½®ç”Ÿæˆå®Œæˆ');

            // è®¾ç½®é€‰é¡¹
            ttftChart.setOption(ttftOption);
            outputChart.setOption(outputOption);
            accuracyChart.setOption(accuracyOption);
            heatmapChart.setOption(heatmapOption);

            console.log('å›¾è¡¨æ¸²æŸ“å®Œæˆ');

            // ä¿å­˜å›¾è¡¨å®ä¾‹åˆ°è®¾å¤‡ç‰¹å®šçš„å­˜å‚¨
            window.chartInstances[deviceKey] = {
              ttftChart: ttftChart,
              outputChart: outputChart,
              accuracyChart: accuracyChart,
              heatmapChart: heatmapChart
            };

            // æ·»åŠ äº‹ä»¶ç›‘å¬
            const resizeObserver = new ResizeObserver(() => {
              ttftChart?.resize();
              outputChart?.resize();
            });

            resizeObserver.observe(ttft3dDiv);
            resizeObserver.observe(output3dDiv);

            return () => {
              resizeObserver.disconnect();
              ttftChart?.dispose();
              outputChart?.dispose();
            };
          } catch (error) {
            console.error('3Då›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', error);
            console.error('é”™è¯¯å †æ ˆ:', error.stack);
          }
        }

        // æ·»åŠ å›¾è¡¨é…ç½®å™¨äº‹ä»¶ç›‘å¬
        function setupChartConfigListeners(chart, perfRows, device) {
          const configSelects = chartConfigContainer.querySelectorAll('select, input');
          configSelects.forEach(element => {
            element.addEventListener('change', () => {
              updateConfigurableChart(chart, perfRows, device);
            });
          });
        }

        // æ·»åŠ æ€§èƒ½æµ‹è¯•ç­›é€‰å™¨äº‹ä»¶ç›‘å¬
        function setupFilterListeners(chart, perfRows, device) {
          const filterSelects = filterContainer.querySelectorAll('select[data-filter]');
          filterSelects.forEach(select => {
            select.addEventListener('change', () => {
              // è·å–ç­›é€‰åçš„æ•°æ®
              const filteredData = getFilteredData();
              updateConfigurableChart(chart, filteredData, device);
            });
          });
        }

        // æ·»åŠ ç²¾åº¦æµ‹è¯•ç­›é€‰å™¨äº‹ä»¶ç›‘å¬
        function setupAccFilterListeners() {
          if (!accFilterContainer) return;

          const filterSelects = accFilterContainer.querySelectorAll('select[data-filter]');
          console.log('ç²¾åº¦ç­›é€‰å™¨æ•°é‡:', filterSelects.length);
          filterSelects.forEach(select => {
            select.addEventListener('change', () => {
              console.log('ç²¾åº¦ç­›é€‰å™¨å˜åŒ–:', select.dataset.filter, select.selectedOptions.length);
              updateAccuracyChart(device);
            });
          });
        }

        // åˆ¤æ–­æ˜¯å¦éœ€è¦ä½¿ç”¨2Då›¾è¡¨
        function shouldUse2D(models, concurrencies, versions, tokenCombinations = []) {
          // å¦‚æœç‰ˆæœ¬æ•°æˆ–å¹¶å‘æ•°åªæœ‰1ä¸ªï¼Œä½¿ç”¨2Då›¾è¡¨
          if (versions.length === 1 || concurrencies.length === 1) {
            return true;
          }

          // è€ƒè™‘æ‰€æœ‰ç»´åº¦ï¼šæ¨¡å‹ã€å¹¶å‘ã€ç‰ˆæœ¬ã€è¾“å…¥è¾“å‡ºç»„åˆ
          const dimensions = [models.length, concurrencies.length, versions.length, tokenCombinations.length];
          const nonSingleDimensions = dimensions.filter(d => d > 1);

          // å¦‚æœæœ‰3ä¸ªæˆ–ä»¥ä¸Šç»´åº¦æœ‰å¤šä¸ªå€¼ï¼Œå¼ºåˆ¶ä½¿ç”¨3Dï¼ˆä½†å®é™…ä¸Š3Dåªèƒ½æ˜¾ç¤º3ä¸ªç»´åº¦ï¼‰
          // å¦‚æœåªæœ‰1-2ä¸ªç»´åº¦æœ‰å¤šä¸ªå€¼ï¼Œä½¿ç”¨2D
          return nonSingleDimensions.length <= 2;
        }

        // è·å–å›¾è¡¨é…ç½®
        function getChartConfig() {
          const activeType = chartConfigContainer.querySelector('.chart-type-option.active');
          const chartType = activeType.dataset.type;

          if (chartType === '2d') {
            return {
              type: '2d',
              xAxis: chartConfigContainer.querySelector('#x-axis-select').value,
              series: chartConfigContainer.querySelector('#series-select').value
            };
          } else {
            return {
              type: '3d',
              xAxis: chartConfigContainer.querySelector('#x-axis-3d-select').value,
              yAxis: chartConfigContainer.querySelector('#y-axis-3d-select').value,
              zAxis: chartConfigContainer.querySelector('#z-axis-3d-select').value
            };
          }
        }

        // æ›´æ–°å›¾è¡¨å’Œè¡¨æ ¼
        function updateChartsAndTable(currentDevice) {
          const filteredData = getFilteredData();
          const chartConfig = getChartConfig();

          console.log('ç­›é€‰åæ•°æ®é‡:', filteredData.length);
          console.log('å›¾è¡¨é…ç½®:', chartConfig);

          // æ›´æ–°è¡¨æ ¼
          updateTable(filteredData);

          // æ ¹æ®é…ç½®ç”Ÿæˆå›¾è¡¨æ•°æ®
          const dimensionData = {
            model: [...new Set(filteredData.map(r => {
              const remark = r.entry?.base_info?.remark?.trim() || '';
              return remark ? `${r.model} (${remark})` : r.model;
            }))].sort(),
            version: [...new Set(filteredData.map(r => r.version))].sort(compareVersionAsc),
            concurrency: [...new Set(filteredData.map(r => r.concurrency))].sort((a, b) => a - b),
            token_combination: [...new Set(filteredData.map(r => {
              const expectedIn = r.expected_input || r.input_tokens;
              const expectedOut = r.expected_output || r.output_tokens;
              return `${expectedIn}/${expectedOut}`;
            }))].sort()
          };

          console.log('ç»´åº¦æ•°æ®:', dimensionData);

          // æ›´æ–°3Då›¾è¡¨æ•°æ®
          function generateFilteredData(type = 'ttft') {
            const data = [];
            console.log(`ç”Ÿæˆ${type}æ•°æ®ï¼Œæ¨¡å‹:`, newModels, 'å¹¶å‘:', newConcurrencies, 'ç‰ˆæœ¬:', newVersions, 'è¾“å…¥è¾“å‡ºç»„åˆ:', newTokenCombinations);

            // å¦‚æœæœ‰å¤šä¸ªè¾“å…¥è¾“å‡ºç»„åˆï¼Œéœ€è¦ä¸ºæ¯ä¸ªç»„åˆç”Ÿæˆæ•°æ®ç‚¹
            if (newTokenCombinations.length > 1) {
              // ä½¿ç”¨è¾“å…¥è¾“å‡ºç»„åˆä½œä¸ºç¬¬ä¸‰ç»´åº¦
              newModels.forEach((model, modelIndex) => {
                newConcurrencies.forEach((concurrency, j) => {
                  newTokenCombinations.forEach((tokenCombo, k) => {
                    const [expectedIn, expectedOut] = tokenCombo.split('/').map(Number);
                    const rows = filteredData.filter(r =>
                      r.model === model &&
                      r.concurrency === concurrency &&
                      (r.expected_input || r.input_tokens) === expectedIn &&
                      (r.expected_output || r.output_tokens) === expectedOut
                    );

                    // å¦‚æœæœ‰å¤šä¸ªç‰ˆæœ¬ï¼Œå–å¹³å‡å€¼æˆ–æœ€æ–°ç‰ˆæœ¬
                    if (rows.length > 0) {
                      const latestRow = rows.sort((a, b) => compareVersionAsc(a.version, b.version)).pop();
                      const value = type === 'ttft' ? latestRow.avg_ttft : latestRow.output_throughput;
                      data.push([
                        j, k, value, model, concurrency, tokenCombo,
                        COLOR_PALETTE[modelIndex % COLOR_PALETTE.length]
                      ]);
                      console.log(`æ·»åŠ æ•°æ®ç‚¹: ${model}-${tokenCombo}-${concurrency} = ${value}`);
                    }
                  });
                });
              });
            } else {
              // åŸæœ‰é€»è¾‘ï¼šä½¿ç”¨ç‰ˆæœ¬ä½œä¸ºç¬¬ä¸‰ç»´åº¦
              newModels.forEach((model, modelIndex) => {
                newConcurrencies.forEach((concurrency, j) => {
                  newVersions.forEach((version, k) => {
                    const rows = filteredData.filter(r =>
                      r.model === model &&
                      r.concurrency === concurrency &&
                      r.version === version
                    );

                    // å¦‚æœæœ‰å¤šä¸ªè¾“å…¥è¾“å‡ºç»„åˆï¼Œå–å¹³å‡å€¼
                    if (rows.length > 0) {
                      const avgValue = rows.reduce((sum, r) => {
                        const val = type === 'ttft' ? r.avg_ttft : r.output_throughput;
                        return sum + val;
                      }, 0) / rows.length;

                      data.push([
                        j, k, avgValue, model, concurrency, version,
                        COLOR_PALETTE[modelIndex % COLOR_PALETTE.length]
                      ]);
                      console.log(`æ·»åŠ æ•°æ®ç‚¹: ${model}-${version}-${concurrency} = ${avgValue} (${rows.length}æ¡æ•°æ®å¹³å‡)`);
                    }
                  });
                });
              });
            }

            console.log(`${type}æ•°æ®ç”Ÿæˆå®Œæˆï¼Œå…±${data.length}ä¸ªæ•°æ®ç‚¹`);
            return data;
          }

          // åˆ›å»º2Då›¾è¡¨é…ç½®
          function create2DChartOption(type) {
            const data = [];
            const categories = [];
            const series = [];

            // ç¡®å®šXè½´ç±»åˆ«å’Œç³»åˆ—ï¼Œä¼˜å…ˆä½¿ç”¨å¹¶å‘æ•°ä½œä¸ºXè½´
            if (newConcurrencies.length > 1) {
              // ä»¥å¹¶å‘æ•°ä¸ºXè½´
              categories.push(...newConcurrencies);
              newModels.forEach((model, modelIndex) => {
                newVersions.forEach(version => {
                  const seriesData = newConcurrencies.map(concurrency => {
                    const rows = filteredData.filter(r =>
                      r.model === model &&
                      r.concurrency === concurrency &&
                      r.version === version
                    );
                    if (rows.length > 0) {
                      const avgValue = rows.reduce((sum, r) => {
                        const val = type === 'ttft' ? r.avg_ttft : r.output_throughput;
                        return sum + val;
                      }, 0) / rows.length;
                      return avgValue;
                    }
                    return null;
                  });

                  if (seriesData.some(val => val !== null)) {
                    const remark = filteredData.find(r => r.model === model)?.entry?.base_info?.remark?.trim() || '';
                    const modelDisplay = remark ? `${model} (${remark})` : model;

                    series.push({
                      name: `${modelDisplay}-${version}`,
                      type: 'bar',
                      data: seriesData,
                      itemStyle: {
                        color: COLOR_PALETTE[modelIndex % COLOR_PALETTE.length]
                      }
                    });
                  }
                });
              });
            } else if (newVersions.length > 1) {
              // ä»¥ç‰ˆæœ¬ä¸ºXè½´
              categories.push(...newVersions);
              newModels.forEach((model, modelIndex) => {
                const seriesData = newVersions.map(version => {
                  const rows = filteredData.filter(r =>
                    r.model === model &&
                    r.version === version
                  );
                  if (rows.length > 0) {
                    const avgValue = rows.reduce((sum, r) => {
                      const val = type === 'ttft' ? r.avg_ttft : r.output_throughput;
                      return sum + val;
                    }, 0) / rows.length;
                    return avgValue;
                  }
                  return null;
                });

                if (seriesData.some(val => val !== null)) {
                  const remark = filteredData.find(r => r.model === model)?.entry?.base_info?.remark?.trim() || '';
                  const modelDisplay = remark ? `${model} (${remark})` : model;

                  series.push({
                    name: modelDisplay,
                    type: 'bar',
                    data: seriesData,
                    itemStyle: {
                      color: COLOR_PALETTE[modelIndex % COLOR_PALETTE.length]
                    }
                  });
                }
              });
            } else {
              // ä»¥æ¨¡å‹ä¸ºXè½´
              const modelDisplayNames = newModels.map(model => {
                const remark = filteredData.find(r => r.model === model)?.entry?.base_info?.remark?.trim() || '';
                return remark ? `${model} (${remark})` : model;
              });
              categories.push(...modelDisplayNames);

              const seriesData = newModels.map(model => {
                const rows = filteredData.filter(r => r.model === model);
                if (rows.length > 0) {
                  const avgValue = rows.reduce((sum, r) => {
                    const val = type === 'ttft' ? r.avg_ttft : r.output_throughput;
                    return sum + val;
                  }, 0) / rows.length;
                  return avgValue;
                }
                return null;
              });

              series.push({
                name: type === 'ttft' ? 'TTFT (ms)' : 'ååé‡ (tokens/s)',
                type: 'bar',
                data: seriesData,
                itemStyle: {
                  color: COLOR_PALETTE[0]
                }
              });
            }

            return {
              backgroundColor: '#fff',
              tooltip: {
                trigger: 'axis',
                backgroundColor: 'rgba(255,255,255,0.98)',
                borderColor: '#e2e8f0',
                borderWidth: 1,
                padding: [8, 12],
                textStyle: {
                  color: '#334155',
                  fontSize: 12
                },
                formatter: function(params) {
                  let result = `<div style="font-weight:bold;margin-bottom:6px;">${params[0].axisValue}</div>`;
                  params.forEach(param => {
                    if (param.value !== null) {
                      // è§£æç³»åˆ—åç§°è·å–æ¨¡å‹å’Œç‰ˆæœ¬ä¿¡æ¯
                      const seriesName = param.seriesName;
                      const color = param.color;

                      // æŸ¥æ‰¾å¯¹åº”çš„æ•°æ®è¡Œè·å–tokensä¿¡æ¯
                      const matchingRow = filteredData.find(r => {
                        if (newConcurrencies.length > 1) {
                          return seriesName.includes(r.model) && seriesName.includes(r.version) && r.concurrency == param.axisValue;
                        } else if (newVersions.length > 1) {
                          return seriesName.includes(r.model) && r.version == param.axisValue;
                        } else {
                          return r.model == param.axisValue;
                        }
                      });

                      const inputTokens = matchingRow?.expected_input || matchingRow?.input_tokens || '-';
                      const outputTokens = matchingRow?.expected_output || matchingRow?.output_tokens || '-';
                      const remark = matchingRow?.entry?.base_info?.remark?.trim() || '';
                      const modelDisplayName = remark ? `${matchingRow?.model} (${remark})` : (matchingRow?.model || seriesName);

                      result += `<div style="margin:2px 0;">
                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};margin-right:6px;"></span>
                        ${modelDisplayName}: <strong>${param.value.toFixed(2)}</strong><br>
                        <span style="margin-left:16px;color:#666;font-size:11px;">è¾“å…¥/è¾“å‡º: ${inputTokens}/${outputTokens}</span>
                      </div>`;
                    }
                  });
                  return result;
                }
              },
              legend: {
                data: series.map(s => s.name),
                top: 10
              },
              xAxis: {
                type: 'category',
                data: categories,
                axisLabel: {
                  rotate: categories.length > 5 ? 45 : 0
                }
              },
              yAxis: {
                type: 'value',
                name: type === 'ttft' ? 'TTFT (ms)' : 'ååé‡ (tokens/s)'
              },
              series: series
            };
          }

          // åˆ›å»ºå®Œæ•´çš„3Då›¾è¡¨é…ç½®
          function createFilteredChartOption(type) {
            const data = generateFilteredData(type);
            console.log(`åˆ›å»º${type}å›¾è¡¨é…ç½®ï¼Œæ•°æ®ç‚¹æ•°é‡:`, data.length);

            return {
              backgroundColor: '#fff',
              tooltip: {
                backgroundColor: 'rgba(255,255,255,0.98)',
                borderColor: '#e2e8f0',
                borderWidth: 1,
                padding: [2, 4],
                textStyle: {
                  color: '#334155',
                  fontSize: 10,
                  lineHeight: 12
                },
                formatter: function(params) {
                  if (!params || !params.data) {
                    return '<div style="font-size:10px;line-height:12px;margin:0;padding:0;">æ•°æ®ä¸å®Œæ•´</div>';
                  }

                  try {
                    const [_, __, rawValue, model, concurrency, version] = params.data;

                    // æŸ¥æ‰¾å®Œæ•´çš„æ•°æ®è¡Œä»¥è·å–æ¨¡å‹æ˜¾ç¤ºåç§°å’Œtokensä¿¡æ¯
                    const fullRow = filteredData.find(r =>
                      r.model === model &&
                      r.concurrency === concurrency &&
                      r.version === version
                    );

                    // è·å–æ¨¡å‹æ˜¾ç¤ºåç§°ï¼ˆåŒ…å«remarkï¼‰
                    const remark = fullRow?.entry?.base_info?.remark?.trim() || '';
                    const modelDisplayName = remark ? `${model} (${remark})` : model;

                    // è·å–è¾“å…¥è¾“å‡ºtokens
                    const inputTokens = fullRow?.expected_input || fullRow?.input_tokens || '-';
                    const outputTokens = fullRow?.expected_output || fullRow?.output_tokens || '-';

                    const value = type === 'ttft'
                      ? `${Number(rawValue).toFixed(2)} ms`
                      : `${Number(rawValue).toFixed(2)} tokens/s`;

                    return `<div style="font-size:10px;line-height:12px;margin:0;padding:0;white-space:nowrap;">
<span style="color:#64748b;">æ¨¡å‹:</span><span style="color:#1e40af;font-weight:600;">${modelDisplayName}</span><br>
<span style="color:#64748b;">ç‰ˆæœ¬:</span><span style="color:#1e40af;font-weight:600;">${version}</span> |
<span style="color:#64748b;">å¹¶å‘:</span><span style="color:#1e40af;font-weight:600;">${concurrency}</span><br>
<span style="color:#64748b;">è¾“å…¥/è¾“å‡º:</span><span style="color:#1e40af;font-weight:600;">${inputTokens}/${outputTokens}</span> |
<span style="color:#64748b;">${type === 'ttft' ? 'TTFT' : 'ååé‡'}:</span><span style="color:#1e40af;font-weight:600;">${value}</span>
</div>`;
                  } catch (error) {
                    console.error('Tooltip æ ¼å¼åŒ–é”™è¯¯:', error);
                    return '<div style="font-size:10px;line-height:12px;margin:0;padding:0;">æ•°æ®æ ¼å¼é”™è¯¯</div>';
                  }
                },
                extraCssText: 'max-width:220px; white-space:normal; word-wrap:break-word; line-height:12px; height:auto;'
              },
              visualMap: {
                max: type === 'ttft' ? 2000 : 50,
                inRange: {
                  color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8']
                }
              },
              xAxis3D: {
                type: 'category',
                name: 'å¹¶å‘æ•°',
                data: newConcurrencies,
                nameGap: 25,
                axisLine: { lineStyle: { width: 2 } },
                axisLabel: { margin: 8, interval: 0 }
              },
              yAxis3D: {
                type: 'category',
                name: newTokenCombinations.length > 1 ? 'è¾“å…¥/è¾“å‡º' : 'ç‰ˆæœ¬',
                data: newTokenCombinations.length > 1 ? newTokenCombinations : newVersions,
                nameGap: 25,
                axisLine: { lineStyle: { width: 2 } },
                axisLabel: { margin: 8, interval: 0 }
              },
              zAxis3D: {
                type: 'value',
                name: type === 'ttft' ? 'TTFT (ms)' : 'ååé‡ (tokens/s)',
                nameGap: 25,
                axisLine: { lineStyle: { width: 2 } }
              },
              grid3D: {
                boxWidth: 180,
                boxHeight: 100,
                boxDepth: 100,
                top: 10,
                bottom: 10,
                left: 10,
                right: 10,
                viewControl: {
                  distance: 200,
                  alpha: 25,
                  beta: 35,
                  rotateSensitivity: 1.5,
                  zoomSensitivity: 1.5,
                  panSensitivity: 1.5,
                  autoRotate: false,  // é»˜è®¤ä¸è‡ªåŠ¨æ—‹è½¬
                  autoRotateSpeed: 2  // å¦‚æœéœ€è¦æ—‹è½¬ï¼Œé€Ÿåº¦å¾ˆæ…¢
                }
              },
              series: [{
                type: 'bar3D',
                data: data,
                shading: 'realistic',
                itemStyle: {
                  opacity: 0.8,
                  borderWidth: 0.5,
                  borderColor: '#fff'
                },
                barSize: 4,
                minHeight: 1,
                label: { show: false }
              }]
            };
          }

          // é‡æ–°è®¾ç½®å›¾è¡¨é€‰é¡¹
          const deviceKey = currentDevice.replace(/\s+/g, '-');
          const chartInstances = window.chartInstances && window.chartInstances[deviceKey];

          if (chartInstances && chartInstances.ttftChart && chartInstances.outputChart) {
            console.log('å¼€å§‹æ›´æ–°å›¾è¡¨...', deviceKey);
            try {
              let ttftOption, outputOption;

              if (use2D) {
                console.log('ä½¿ç”¨2Då›¾è¡¨é…ç½®');
                ttftOption = create2DChartOption('ttft');
                outputOption = create2DChartOption('output');
              } else {
                console.log('ä½¿ç”¨3Då›¾è¡¨é…ç½®');
                ttftOption = createFilteredChartOption('ttft');
                outputOption = createFilteredChartOption('output');
                console.log('TTFTå›¾è¡¨æ•°æ®ç‚¹æ•°é‡:', ttftOption.series[0].data.length);
                console.log('è¾“å‡ºå›¾è¡¨æ•°æ®ç‚¹æ•°é‡:', outputOption.series[0].data.length);
              }

              chartInstances.ttftChart.setOption(ttftOption, true);
              chartInstances.outputChart.setOption(outputOption, true);

              // æ›´æ–°ç²¾åº¦å›¾è¡¨
              if (chartInstances.accuracyChart) {
                // ç­›é€‰ç²¾åº¦æ•°æ®
                const filteredAccRows = accRows.filter(row => {
                  return filteredData.some(perfRow =>
                    perfRow.model === row.model && perfRow.version === row.version
                  );
                });

                console.log('åŸå§‹ç²¾åº¦æ•°æ®é‡:', accRows.length);
                console.log('ç­›é€‰åç²¾åº¦æ•°æ®é‡:', filteredAccRows.length);
                console.log('ç­›é€‰åç²¾åº¦æ•°æ®:', filteredAccRows.map(r => ({
                  model: r.model,
                  version: r.version,
                  remark: r.entry?.base_info?.remark,
                  score: r.score
                })));

                // ä¸´æ—¶ä¿å­˜åŸå§‹accRowsï¼Œç”¨ç­›é€‰åçš„æ•°æ®ç”Ÿæˆå›¾è¡¨
                const originalAccRows = accRows;
                accRows = filteredAccRows;
                const accuracyOption = getAccuracyChartOption();
                accRows = originalAccRows; // æ¢å¤åŸå§‹æ•°æ®

                chartInstances.accuracyChart.setOption(accuracyOption, true);
                console.log('ç²¾åº¦å›¾è¡¨æ›´æ–°å®Œæˆ');
              }

              console.log('å›¾è¡¨æ›´æ–°å®Œæˆ');
            } catch (error) {
              console.error('å›¾è¡¨æ›´æ–°å¤±è´¥:', error);
            }
          } else {
            console.error('å›¾è¡¨å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•æ›´æ–°', deviceKey, chartInstances);
          }
        }

        // æ›´æ–°ç²¾åº¦å›¾è¡¨
        function updateAccuracyChart(currentDevice) {
          const filteredAccData = getFilteredAccData();
          console.log('ç­›é€‰åç²¾åº¦æ•°æ®é‡:', filteredAccData.length);

          const deviceKey = currentDevice.replace(/\s+/g, '-');
          const chartInstances = window.chartInstances && window.chartInstances[deviceKey];

          if (chartInstances && chartInstances.accuracyChart) {
            console.log('å¼€å§‹æ›´æ–°ç²¾åº¦å›¾è¡¨...', deviceKey);
            try {
              // ä¸´æ—¶ä¿å­˜åŸå§‹accRowsï¼Œç”¨ç­›é€‰åçš„æ•°æ®ç”Ÿæˆå›¾è¡¨
              const originalAccRows = accRows;
              accRows = filteredAccData;
              const accuracyOption = getAccuracyChartOption();
              accRows = originalAccRows; // æ¢å¤åŸå§‹æ•°æ®

              chartInstances.accuracyChart.setOption(accuracyOption, true);
              console.log('ç²¾åº¦å›¾è¡¨æ›´æ–°å®Œæˆ');
            } catch (error) {
              console.error('ç²¾åº¦å›¾è¡¨æ›´æ–°å¤±è´¥:', error);
            }
          } else {
            console.error('ç²¾åº¦å›¾è¡¨å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•æ›´æ–°', deviceKey, chartInstances);
          }
        }

        // è·å–ç­›é€‰åçš„ç²¾åº¦æ•°æ®
        function getFilteredAccData() {
          if (!accFilterContainer) {
            console.log('ç²¾åº¦ç­›é€‰å™¨å®¹å™¨ä¸å­˜åœ¨ï¼Œè¿”å›åŸå§‹æ•°æ®');
            return accRows;
          }

          const filterSelects = accFilterContainer.querySelectorAll('select[data-filter]');
          console.log('ç²¾åº¦ç­›é€‰å™¨æ•°é‡:', filterSelects.length);

          // æ”¶é›†æ‰€æœ‰ç­›é€‰æ¡ä»¶
          const filters = {};
          filterSelects.forEach(select => {
            const filterType = select.dataset.filter;
            const selectedValues = Array.from(select.selectedOptions)
              .map(option => option.value)
              .filter(value => value !== '__ALL__'); // è¿‡æ»¤æ‰å…¨é€‰é€‰é¡¹
            if (selectedValues.length > 0) {
              filters[filterType] = selectedValues;
            }
          });

          console.log('å½“å‰ç²¾åº¦ç­›é€‰æ¡ä»¶:', filters);

          const filtered = accRows.filter(row => {
            // æ£€æŸ¥æ¯ä¸ªç­›é€‰æ¡ä»¶
            for (const [filterType, selectedValues] of Object.entries(filters)) {
              let match = false;

              // æ ¹æ®ç­›é€‰ç±»å‹è¿›è¡ŒåŒ¹é…
              switch (filterType) {
                case 'model':
                  // æ„å»ºå½“å‰è¡Œçš„æ¨¡å‹ç»„åˆé”®
                  const rowRemark = row.entry?.base_info?.remark?.trim() || '';
                  const rowModelKey = rowRemark ? `${row.model}_${rowRemark}` : row.model;
                  match = selectedValues.includes(rowModelKey);
                  break;
                case 'version':
                  match = selectedValues.includes(row.version);
                  break;
              }

              // å¦‚æœä»»ä½•ä¸€ä¸ªç­›é€‰æ¡ä»¶ä¸åŒ¹é…ï¼Œåˆ™æ’é™¤è¯¥è¡Œ
              if (!match) return false;
            }
            return true;
          });

          console.log('ç²¾åº¦ç­›é€‰ç»“æœ:', filtered.length, '/', accRows.length);
          return filtered;
        }

        // è·å–ç­›é€‰åçš„æ•°æ®
        function getFilteredData() {
          const filterSelects = filterContainer.querySelectorAll('select[data-filter]');
          console.log('ç­›é€‰å™¨æ•°é‡:', filterSelects.length);

          // æ”¶é›†æ‰€æœ‰ç­›é€‰æ¡ä»¶
          const filters = {};
          filterSelects.forEach(select => {
            const filterType = select.dataset.filter;
            const selectedValues = Array.from(select.selectedOptions)
              .map(option => option.value)
              .filter(value => value !== '__ALL__'); // è¿‡æ»¤æ‰å…¨é€‰é€‰é¡¹
            if (selectedValues.length > 0) {
              filters[filterType] = selectedValues;
            }
          });

          console.log('å½“å‰ç­›é€‰æ¡ä»¶:', filters);

          const filtered = perfRows.filter(row => {
            // æ£€æŸ¥æ¯ä¸ªç­›é€‰æ¡ä»¶
            for (const [filterType, selectedValues] of Object.entries(filters)) {
              let match = false;

              // æ ¹æ®ç­›é€‰ç±»å‹è¿›è¡ŒåŒ¹é…
              switch (filterType) {
                case 'model':
                  // æ„å»ºå½“å‰è¡Œçš„æ¨¡å‹ç»„åˆé”®
                  const rowRemark = row.entry?.base_info?.remark?.trim() || '';
                  const rowModelKey = rowRemark ? `${row.model}_${rowRemark}` : row.model;
                  match = selectedValues.includes(rowModelKey);
                  break;
                case 'version':
                  match = selectedValues.includes(row.version);
                  break;
                case 'concurrency':
                  match = selectedValues.includes(row.concurrency.toString());
                  break;
                case 'token_combination':
                  const expectedIn = row.expected_input || row.input_tokens;
                  const expectedOut = row.expected_output || row.output_tokens;
                  const combination = `${expectedIn}/${expectedOut}`;
                  match = selectedValues.includes(combination);
                  break;
              }

              // å¦‚æœä»»ä½•ä¸€ä¸ªç­›é€‰æ¡ä»¶ä¸åŒ¹é…ï¼Œåˆ™æ’é™¤è¯¥è¡Œ
              if (!match) return false;
            }
            return true;
          });

          console.log('ç­›é€‰ç»“æœ:', filtered.length, '/', perfRows.length);
          return filtered;
        }

        // æ›´æ–°è¡¨æ ¼ (è™½ç„¶éšè—äº†ï¼Œä½†ä¿æŒæ•°æ®åŒæ­¥)
        function updateTable(filteredData) {
          const tbody = tableContainer.querySelector('tbody');
          tbody.innerHTML = filteredData.map(row => `
            <tr>
              <td>${row.model}</td>
              <td>${row.version}</td>
              <td class="number">${row.concurrency}</td>
              <td class="number">${row.expected_input || row.input_tokens}</td>
              <td class="number">${row.expected_output || row.output_tokens}</td>
              <td class="number">${row.output_throughput?.toFixed(2) || '-'}</td>
              <td class="number">${row.total_throughput?.toFixed(2) || '-'}</td>
              <td class="number">${row.avg_ttft?.toFixed(2) || '-'}</td>
              <td class="number">${row.p99_ttft?.toFixed(2) || '-'}</td>
            </tr>
          `).join('');
        }

        // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿DOMå·²æ›´æ–°
        requestAnimationFrame(() => {
          setTimeout(() => {
            if (ttft3dDiv.isConnected && output3dDiv.isConnected) {
              const cleanup = initCharts();

              // è®¾ç½®å›¾è¡¨é…ç½®å™¨ç›‘å¬
              setupChartConfigListeners();

              // è®¾ç½®æ€§èƒ½æµ‹è¯•ç­›é€‰å™¨ç›‘å¬
              setupFilterListeners();

              // è®¾ç½®ç²¾åº¦æµ‹è¯•ç­›é€‰å™¨ç›‘å¬
              if (accFilterContainer) {
                setupAccFilterListeners();
              }
            } else {
              console.error('å®¹å™¨å°šæœªæ·»åŠ åˆ°DOM');
            }
          }, 100);
        });

      } catch (error) {
        console.error('æ•´ä½“æ¸²æŸ“å¤±è´¥:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
      }
    }

    function drawBarChartsWithGradient() {
      // ç”±äºæ¸å˜éœ€è¦ canvas context,è¿™ä¸ªå‡½æ•°å¯ä»¥ç•™ç©º
      // æˆ–è€…ä¹‹åå†æ·»åŠ æ¸å˜æ•ˆæœ
    }
    fetchAllResults().then(renderGroupedResults).then(() => {
      // ç­‰å¾…æ‰€æœ‰å›¾è¡¨åˆå§‹åŒ–å®Œæˆåï¼Œæ‰‹åŠ¨è§¦å‘é»˜è®¤é…ç½®
      setTimeout(() => {
        console.log('ğŸ”„ æ‰‹åŠ¨è§¦å‘æ‰€æœ‰é»˜è®¤é…ç½®');
        // æŸ¥æ‰¾æ‰€æœ‰é…ç½®å®¹å™¨å¹¶æ£€æŸ¥éœ€è¦é»˜è®¤é…ç½®çš„
        const allConfigContainers = document.querySelectorAll('.chart-config-container');
        console.log('æ‰€æœ‰é…ç½®å®¹å™¨æ•°é‡:', allConfigContainers.length);

        const configContainers = Array.from(allConfigContainers).filter(container => {
          const needsConfig = container.dataset.needsDefaultConfig === 'true';
          console.log('å®¹å™¨è®¾å¤‡:', container.dataset.device, 'éœ€è¦é»˜è®¤é…ç½®:', needsConfig);
          return needsConfig;
        });
        console.log('æ‰¾åˆ°éœ€è¦é»˜è®¤é…ç½®çš„å®¹å™¨æ•°é‡:', configContainers.length);

        configContainers.forEach(container => {
          const device = container.dataset.device;
          console.log('ğŸ¯ ä¸ºè®¾å¤‡è®¾ç½®é»˜è®¤é…ç½®:', device);

          // è·å–è¯¥è®¾å¤‡çš„æ•°æ®
          const deviceKey = String(device).replace(/\s+/g, '-');
          const perfRows = window.devicePerfRows?.[deviceKey] || window.currentPerfRows || [];

          if (perfRows.length > 0) {
            setDefaultConfiguration(container, device, perfRows);
            container.dataset.needsDefaultConfig = 'false';
          } else {
            console.log('âŒ æ²¡æœ‰æ‰¾åˆ°è®¾å¤‡æ•°æ®:', device);
          }
        });
      }, 1500);

      // é¢å¤–çš„å¤‡ç”¨è§¦å‘æœºåˆ¶
      setTimeout(() => {
        console.log('ğŸ”„ å¤‡ç”¨é»˜è®¤é…ç½®è§¦å‘');
        const allContainers = document.querySelectorAll('.chart-config-container');
        console.log('å¤‡ç”¨æœºåˆ¶æ‰¾åˆ°å®¹å™¨æ•°é‡:', allContainers.length);
        allContainers.forEach(container => {
          const device = container.dataset.device;
          console.log('æ£€æŸ¥è®¾å¤‡:', device);
          if (device && device.includes('s4000')) {
            console.log('ğŸ¯ ä¸ºS4000è®¾å¤‡å¼ºåˆ¶è®¾ç½®é»˜è®¤é…ç½®');
            const deviceKey = String(device).replace(/\s+/g, '-');
            const perfRows = window.devicePerfRows?.[deviceKey] || [];
            console.log('S4000æ•°æ®é‡:', perfRows.length);

            if (perfRows.length > 0) {
              // ç›´æ¥è®¾ç½®é…ç½®
              const dim1Select = container.querySelector('#dim1-select');
              const dim2Select = container.querySelector('#dim2-select');
              const xAxisSelect = container.querySelector('#x-axis-select');

              console.log('æ‰¾åˆ°é€‰æ‹©å™¨: dim1=', !!dim1Select, 'dim2=', !!dim2Select, 'xAxis=', !!xAxisSelect);

              if (dim1Select && dim2Select && xAxisSelect) {
                console.log('ğŸ”§ ç›´æ¥è®¾ç½®S4000é»˜è®¤é…ç½®');

                // è®¾ç½®æ¨¡å‹ç»´åº¦
                console.log('è®¾ç½®ç»´åº¦1ä¸ºmodel');
                dim1Select.value = 'model';
                dim1Select.dispatchEvent(new Event('change', { bubbles: true }));

                setTimeout(() => {
                  const dim1ValueSelect = container.querySelector('#dim1-value');
                  console.log('æ‰¾åˆ°dim1ValueSelect:', !!dim1ValueSelect);

                  if (dim1ValueSelect) {
                    const models = Array.from(dim1ValueSelect.options).map(o => o.value).filter(v => v);
                    console.log('å¯ç”¨æ¨¡å‹:', models.join(', '));
                    const target671b = models.find(m => m.toLowerCase().includes('671b') && m.includes('6core'));
                    console.log('æ‰¾åˆ°671Bæ¨¡å‹:', target671b);

                    if (target671b) {
                      dim1ValueSelect.value = target671b;
                      dim1ValueSelect.dispatchEvent(new Event('change', { bubbles: true }));
                      console.log('âœ… S4000æ¨¡å‹å·²è®¾ç½®:', target671b);

                      // è®¾ç½®ç‰ˆæœ¬ç»´åº¦
                      setTimeout(() => {
                        dim2Select.value = 'version';
                        dim2Select.dispatchEvent(new Event('change', { bubbles: true }));

                        setTimeout(() => {
                          const dim2ValueSelect = container.querySelector('#dim2-value');
                          if (dim2ValueSelect && dim2ValueSelect.options.length > 1) {
                            dim2ValueSelect.value = dim2ValueSelect.options[dim2ValueSelect.options.length - 1].value;
                            dim2ValueSelect.dispatchEvent(new Event('change', { bubbles: true }));

                            // è®¾ç½®Xè½´
                            setTimeout(() => {
                              xAxisSelect.value = 'concurrency';
                              xAxisSelect.dispatchEvent(new Event('change', { bubbles: true }));
                              console.log('âœ… S4000é»˜è®¤é…ç½®å®Œæˆ');
                            }, 100);
                          }
                        }, 200);
                      }, 200);
                    }
                  }
                }, 300);
              }
            }
          }
        });
      }, 3000);
    }).catch(err => {
      document.getElementById("app").innerHTML = `<p style="color:red;">âŒ åŠ è½½å¤±è´¥: ${err.message}</p>`;
      console.error(err);
    });
  </script>
  <script>
    // æ£€æŸ¥ ECharts ç‰ˆæœ¬
    window.addEventListener('load', () => {
      if (echarts) {
        console.log('ECharts ç‰ˆæœ¬:', echarts.version);
      } else {
        console.error('ECharts æœªåŠ è½½');
      }
    });
  </script>
</body>
</html>
